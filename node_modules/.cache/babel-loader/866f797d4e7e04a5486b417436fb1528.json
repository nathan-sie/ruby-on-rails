{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { throwError } from '../../../../utils/error.mjs';\nimport createList from '../builders/build-list.mjs';\nimport { isHorizontal } from '../utils.mjs';\nimport { SMART_ALIGNMENT, AUTO_ALIGNMENT, CENTERED_ALIGNMENT, END_ALIGNMENT, START_ALIGNMENT, DEFAULT_DYNAMIC_LIST_ITEM_SIZE } from '../defaults.mjs';\nvar SCOPE = \"ElDynamicSizeList\";\n\nvar getItemFromCache = function getItemFromCache(props, index, listCache) {\n  var itemSize = props.itemSize;\n  var items = listCache.items,\n      lastVisitedIndex = listCache.lastVisitedIndex;\n\n  if (index > lastVisitedIndex) {\n    var offset = 0;\n\n    if (lastVisitedIndex >= 0) {\n      var item = items[lastVisitedIndex];\n      offset = item.offset + item.size;\n    }\n\n    for (var i = lastVisitedIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      items[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    listCache.lastVisitedIndex = index;\n  }\n\n  return items[index];\n};\n\nvar findItem = function findItem(props, listCache, offset) {\n  var items = listCache.items,\n      lastVisitedIndex = listCache.lastVisitedIndex;\n  var lastVisitedOffset = lastVisitedIndex > 0 ? items[lastVisitedIndex].offset : 0;\n\n  if (lastVisitedOffset >= offset) {\n    return bs(props, listCache, 0, lastVisitedIndex, offset);\n  }\n\n  return es(props, listCache, Math.max(0, lastVisitedIndex), offset);\n};\n\nvar bs = function bs(props, listCache, low, high, offset) {\n  while (low <= high) {\n    var mid = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemFromCache(props, mid, listCache).offset;\n\n    if (currentOffset === offset) {\n      return mid;\n    } else if (currentOffset < offset) {\n      low = mid + 1;\n    } else if (currentOffset > offset) {\n      high = mid - 1;\n    }\n  }\n\n  return Math.max(0, low - 1);\n};\n\nvar es = function es(props, listCache, index, offset) {\n  var total = props.total;\n  var exponent = 1;\n\n  while (index < total && getItemFromCache(props, index, listCache).offset < offset) {\n    index += exponent;\n    exponent *= 2;\n  }\n\n  return bs(props, listCache, Math.floor(index / 2), Math.min(index, total - 1), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref, _ref2) {\n  var total = _ref.total;\n  var items = _ref2.items,\n      estimatedItemSize = _ref2.estimatedItemSize,\n      lastVisitedIndex = _ref2.lastVisitedIndex;\n  var totalSizeOfMeasuredItems = 0;\n\n  if (lastVisitedIndex >= total) {\n    lastVisitedIndex = total - 1;\n  }\n\n  if (lastVisitedIndex >= 0) {\n    var item = items[lastVisitedIndex];\n    totalSizeOfMeasuredItems = item.offset + item.size;\n  }\n\n  var numUnmeasuredItems = total - lastVisitedIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar DynamicSizeList = createList({\n  name: \"ElDynamicSizeList\",\n  getItemOffset: function getItemOffset(props, index, listCache) {\n    return getItemFromCache(props, index, listCache).offset;\n  },\n  getItemSize: function getItemSize(_, index, _ref3) {\n    var items = _ref3.items;\n    return items[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffset: function getOffset(props, index, alignment, scrollOffset, listCache) {\n    var height = props.height,\n        layout = props.layout,\n        width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, index, listCache);\n    var estimatedTotalSize = getEstimatedTotalSize(props, listCache);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, item.offset));\n    var minOffset = Math.max(0, item.offset - size + item.size);\n\n    if (alignment === SMART_ALIGNMENT) {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        alignment = AUTO_ALIGNMENT;\n      } else {\n        alignment = CENTERED_ALIGNMENT;\n      }\n    }\n\n    switch (alignment) {\n      case START_ALIGNMENT:\n        {\n          return maxOffset;\n        }\n\n      case END_ALIGNMENT:\n        {\n          return minOffset;\n        }\n\n      case CENTERED_ALIGNMENT:\n        {\n          return Math.round(minOffset + (maxOffset - minOffset) / 2);\n        }\n\n      case AUTO_ALIGNMENT:\n      default:\n        {\n          if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n            return scrollOffset;\n          } else if (scrollOffset < minOffset) {\n            return minOffset;\n          } else {\n            return maxOffset;\n          }\n        }\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, listCache) {\n    return findItem(props, listCache, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, listCache) {\n    var height = props.height,\n        total = props.total,\n        layout = props.layout,\n        width = props.width;\n    var size = isHorizontal(layout) ? width : height;\n    var item = getItemFromCache(props, startIndex, listCache);\n    var maxOffset = scrollOffset + size;\n    var offset = item.offset + item.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < total - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemFromCache(props, stopIndex, listCache).size;\n    }\n\n    return stopIndex;\n  },\n  initCache: function initCache(_ref4, instance) {\n    var _ref4$estimatedItemSi = _ref4.estimatedItemSize,\n        estimatedItemSize = _ref4$estimatedItemSi === void 0 ? DEFAULT_DYNAMIC_LIST_ITEM_SIZE : _ref4$estimatedItemSi;\n    var cache = {\n      items: {},\n      estimatedItemSize: estimatedItemSize,\n      lastVisitedIndex: -1\n    };\n\n    cache.clearCacheAfterIndex = function (index) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var _a, _b;\n\n      cache.lastVisitedIndex = Math.min(cache.lastVisitedIndex, index - 1);\n      (_a = instance.exposed) == null ? void 0 : _a.getItemStyleCache(-1);\n\n      if (forceUpdate) {\n        (_b = instance.proxy) == null ? void 0 : _b.$forceUpdate();\n      }\n    };\n\n    return cache;\n  },\n  clearCache: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof itemSize !== \"function\") {\n        throwError(SCOPE, \"\\n          itemSize is required as function, but the given value was \".concat(_typeof(itemSize), \"\\n        \"));\n      }\n    }\n  }\n});\nexport { DynamicSizeList as default };","map":null,"metadata":{},"sourceType":"module"}