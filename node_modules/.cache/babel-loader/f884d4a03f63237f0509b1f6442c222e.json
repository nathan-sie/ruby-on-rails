{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { hasOwn } from '@vue/shared';\nimport { createPopper } from '@popperjs/core';\nimport PopupManager from '../../../utils/popup-manager.mjs';\nimport { getValueByPath } from '../../../utils/util.mjs';\nimport { off, on } from '../../../utils/dom.mjs';\n\nvar getCell = function getCell(event) {\n  var cell = event.target;\n\n  while (cell && cell.tagName.toUpperCase() !== \"HTML\") {\n    if (cell.tagName.toUpperCase() === \"TD\") {\n      return cell;\n    }\n\n    cell = cell.parentNode;\n  }\n\n  return null;\n};\n\nvar isObject = function isObject(obj) {\n  return obj !== null && _typeof(obj) === \"object\";\n};\n\nvar orderBy = function orderBy(array, sortKey, reverse, sortMethod, sortBy) {\n  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {\n    return array;\n  }\n\n  if (typeof reverse === \"string\") {\n    reverse = reverse === \"descending\" ? -1 : 1;\n  } else {\n    reverse = reverse && reverse < 0 ? -1 : 1;\n  }\n\n  var getKey = sortMethod ? null : function (value, index) {\n    if (sortBy) {\n      if (!Array.isArray(sortBy)) {\n        sortBy = [sortBy];\n      }\n\n      return sortBy.map(function (by) {\n        if (typeof by === \"string\") {\n          return getValueByPath(value, by);\n        } else {\n          return by(value, index, array);\n        }\n      });\n    }\n\n    if (sortKey !== \"$key\") {\n      if (isObject(value) && \"$value\" in value) value = value.$value;\n    }\n\n    return [isObject(value) ? getValueByPath(value, sortKey) : value];\n  };\n\n  var compare = function compare(a, b) {\n    if (sortMethod) {\n      return sortMethod(a.value, b.value);\n    }\n\n    for (var i = 0, len = a.key.length; i < len; i++) {\n      if (a.key[i] < b.key[i]) {\n        return -1;\n      }\n\n      if (a.key[i] > b.key[i]) {\n        return 1;\n      }\n    }\n\n    return 0;\n  };\n\n  return array.map(function (value, index) {\n    return {\n      value: value,\n      index: index,\n      key: getKey ? getKey(value, index) : null\n    };\n  }).sort(function (a, b) {\n    var order = compare(a, b);\n\n    if (!order) {\n      order = a.index - b.index;\n    }\n\n    return order * +reverse;\n  }).map(function (item) {\n    return item.value;\n  });\n};\n\nvar getColumnById = function getColumnById(table, columnId) {\n  var column = null;\n  table.columns.forEach(function (item) {\n    if (item.id === columnId) {\n      column = item;\n    }\n  });\n  return column;\n};\n\nvar getColumnByKey = function getColumnByKey(table, columnKey) {\n  var column = null;\n\n  for (var i = 0; i < table.columns.length; i++) {\n    var item = table.columns[i];\n\n    if (item.columnKey === columnKey) {\n      column = item;\n      break;\n    }\n  }\n\n  return column;\n};\n\nvar getColumnByCell = function getColumnByCell(table, cell) {\n  var matches = (cell.className || \"\").match(/el-table_[^\\s]+/gm);\n\n  if (matches) {\n    return getColumnById(table, matches[0]);\n  }\n\n  return null;\n};\n\nvar getRowIdentity = function getRowIdentity(row, rowKey) {\n  if (!row) throw new Error(\"Row is required when get row identity\");\n\n  if (typeof rowKey === \"string\") {\n    if (rowKey.indexOf(\".\") < 0) {\n      return \"\".concat(row[rowKey]);\n    }\n\n    var key = rowKey.split(\".\");\n    var current = row;\n\n    for (var i = 0; i < key.length; i++) {\n      current = current[key[i]];\n    }\n\n    return \"\".concat(current);\n  } else if (typeof rowKey === \"function\") {\n    return rowKey.call(null, row);\n  }\n};\n\nvar getKeysMap = function getKeysMap(array, rowKey) {\n  var arrayMap = {};\n  (array || []).forEach(function (row, index) {\n    arrayMap[getRowIdentity(row, rowKey)] = {\n      row: row,\n      index: index\n    };\n  });\n  return arrayMap;\n};\n\nfunction mergeOptions(defaults, config) {\n  var options = {};\n  var key;\n\n  for (key in defaults) {\n    options[key] = defaults[key];\n  }\n\n  for (key in config) {\n    if (hasOwn(config, key)) {\n      var value = config[key];\n\n      if (typeof value !== \"undefined\") {\n        options[key] = value;\n      }\n    }\n  }\n\n  return options;\n}\n\nfunction parseWidth(width) {\n  if (width !== void 0) {\n    width = parseInt(width, 10);\n\n    if (isNaN(width)) {\n      width = null;\n    }\n  }\n\n  return +width;\n}\n\nfunction parseMinWidth(minWidth) {\n  if (typeof minWidth !== \"undefined\") {\n    minWidth = parseWidth(minWidth);\n\n    if (isNaN(minWidth)) {\n      minWidth = 80;\n    }\n  }\n\n  return minWidth;\n}\n\nfunction parseHeight(height) {\n  if (typeof height === \"number\") {\n    return height;\n  }\n\n  if (typeof height === \"string\") {\n    if (/^\\d+(?:px)?$/.test(height)) {\n      return parseInt(height, 10);\n    } else {\n      return height;\n    }\n  }\n\n  return null;\n}\n\nfunction compose() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(void 0, arguments));\n    };\n  });\n}\n\nfunction toggleRowStatus(statusArr, row, newVal) {\n  var changed = false;\n  var index = statusArr.indexOf(row);\n  var included = index !== -1;\n\n  var addRow = function addRow() {\n    statusArr.push(row);\n    changed = true;\n  };\n\n  var removeRow = function removeRow() {\n    statusArr.splice(index, 1);\n    changed = true;\n  };\n\n  if (typeof newVal === \"boolean\") {\n    if (newVal && !included) {\n      addRow();\n    } else if (!newVal && included) {\n      removeRow();\n    }\n  } else {\n    if (included) {\n      removeRow();\n    } else {\n      addRow();\n    }\n  }\n\n  return changed;\n}\n\nfunction walkTreeNode(root, cb) {\n  var childrenKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"children\";\n  var lazyKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"hasChildren\";\n\n  var isNil = function isNil(array) {\n    return !(Array.isArray(array) && array.length);\n  };\n\n  function _walker(parent, children, level) {\n    cb(parent, children, level);\n    children.forEach(function (item) {\n      if (item[lazyKey]) {\n        cb(item, null, level + 1);\n        return;\n      }\n\n      var children2 = item[childrenKey];\n\n      if (!isNil(children2)) {\n        _walker(item, children2, level + 1);\n      }\n    });\n  }\n\n  root.forEach(function (item) {\n    if (item[lazyKey]) {\n      cb(item, null, 0);\n      return;\n    }\n\n    var children = item[childrenKey];\n\n    if (!isNil(children)) {\n      _walker(item, children, 0);\n    }\n  });\n}\n\nvar removePopper;\n\nfunction createTablePopper(trigger, popperContent, popperOptions, tooltipEffect) {\n  function renderContent() {\n    var isLight = tooltipEffect === \"light\";\n    var content2 = document.createElement(\"div\");\n    content2.className = \"el-popper \".concat(isLight ? \"is-light\" : \"is-dark\");\n    content2.innerHTML = popperContent;\n    content2.style.zIndex = String(PopupManager.nextZIndex());\n    document.body.appendChild(content2);\n    return content2;\n  }\n\n  function renderArrow() {\n    var arrow2 = document.createElement(\"div\");\n    arrow2.className = \"el-popper__arrow\";\n    arrow2.style.bottom = \"-4px\";\n    return arrow2;\n  }\n\n  function showPopper() {\n    popperInstance && popperInstance.update();\n  }\n\n  removePopper = function removePopper2() {\n    try {\n      popperInstance && popperInstance.destroy();\n      content && document.body.removeChild(content);\n      off(trigger, \"mouseenter\", showPopper);\n      off(trigger, \"mouseleave\", removePopper2);\n    } catch (e) {}\n  };\n\n  var popperInstance = null;\n  var content = renderContent();\n  var arrow = renderArrow();\n  content.appendChild(arrow);\n  popperInstance = createPopper(trigger, content, _objectSpread({\n    modifiers: [{\n      name: \"offset\",\n      options: {\n        offset: [0, 8]\n      }\n    }, {\n      name: \"arrow\",\n      options: {\n        element: arrow,\n        padding: 10\n      }\n    }]\n  }, popperOptions));\n  on(trigger, \"mouseenter\", showPopper);\n  on(trigger, \"mouseleave\", removePopper);\n  return popperInstance;\n}\n\nexport { compose, createTablePopper, getCell, getColumnByCell, getColumnById, getColumnByKey, getKeysMap, getRowIdentity, mergeOptions, orderBy, parseHeight, parseMinWidth, parseWidth, removePopper, toggleRowStatus, walkTreeNode };","map":null,"metadata":{},"sourceType":"module"}