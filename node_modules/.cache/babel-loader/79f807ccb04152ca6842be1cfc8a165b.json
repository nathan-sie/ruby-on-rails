{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getCurrentInstance, ref, computed, toRef, nextTick, h, Transition, renderSlot, toDisplayString, cloneVNode, Fragment, withDirectives } from 'vue';\nimport { isString, NOOP } from '@vue/shared';\nimport { createPopper } from '@popperjs/core';\nimport '../../directives/index.mjs';\nimport { generateId, isHTMLElement, refAttacher } from '../../utils/util.mjs';\nimport { getFirstValidNode } from '../../utils/vnode.mjs';\nimport { stop } from '../../utils/dom.mjs';\nimport PopupManager from '../../utils/popup-manager.mjs';\nimport { throwError } from '../../utils/error.mjs';\nimport useTeleport from '../use-teleport/index.mjs';\nimport useTimeout from '../use-timeout/index.mjs';\nimport { useModelToggle } from '../use-model-toggle/index.mjs';\nimport { useTransitionFallthrough } from '../use-transition-fallthrough/index.mjs';\nimport { defaultPopperOptions, defaultModifiers } from './use-popper-options.mjs';\nimport { DEFAULT_TRIGGER, useTargetEvents } from './use-target-events.mjs';\nimport ClickOutside from '../../directives/click-outside/index.mjs';\nvar DARK_EFFECT = \"dark\";\nvar LIGHT_EFFECT = \"light\";\nvar usePopperControlProps = {\n  appendToBody: {\n    type: Boolean,\n    \"default\": true\n  },\n  arrowOffset: {\n    type: Number\n  },\n  popperOptions: defaultPopperOptions,\n  popperClass: {\n    type: String,\n    \"default\": \"\"\n  }\n};\n\nvar usePopperProps = _objectSpread(_objectSpread({}, usePopperControlProps), {}, {\n  autoClose: {\n    type: Number,\n    \"default\": 0\n  },\n  content: {\n    type: String,\n    \"default\": \"\"\n  },\n  \"class\": String,\n  style: Object,\n  hideAfter: {\n    type: Number,\n    \"default\": 200\n  },\n  disabled: {\n    type: Boolean,\n    \"default\": false\n  },\n  effect: {\n    type: String,\n    \"default\": DARK_EFFECT\n  },\n  enterable: {\n    type: Boolean,\n    \"default\": true\n  },\n  manualMode: {\n    type: Boolean,\n    \"default\": false\n  },\n  showAfter: {\n    type: Number,\n    \"default\": 0\n  },\n  pure: {\n    type: Boolean,\n    \"default\": false\n  },\n  showArrow: {\n    type: Boolean,\n    \"default\": true\n  },\n  transition: {\n    type: String,\n    \"default\": \"el-fade-in-linear\"\n  },\n  trigger: {\n    type: [String, Array],\n    \"default\": DEFAULT_TRIGGER\n  },\n  visible: {\n    type: Boolean,\n    \"default\": void 0\n  },\n  stopPopperMouseEvent: {\n    type: Boolean,\n    \"default\": true\n  }\n});\n\nvar usePopperHook = function usePopperHook() {\n  var _a;\n\n  var vm = getCurrentInstance();\n  var props = (_a = vm.proxy) == null ? void 0 : _a.$props;\n  var slots = vm.slots;\n  var arrowRef = ref(null);\n  var triggerRef = ref(null);\n  var popperRef = ref(null);\n  var popperStyle = ref({\n    zIndex: PopupManager.nextZIndex()\n  });\n  var visible = ref(false);\n  var isManual = computed(function () {\n    return props.manualMode || props.trigger === \"manual\";\n  });\n  var popperId = \"el-popper-\".concat(generateId());\n  var popperInstance = null;\n\n  var _useTeleport = useTeleport(popupRenderer, toRef(props, \"appendToBody\")),\n      renderTeleport = _useTeleport.renderTeleport,\n      showTeleport = _useTeleport.showTeleport,\n      hideTeleport = _useTeleport.hideTeleport;\n\n  var _useModelToggle = useModelToggle({\n    indicator: visible,\n    onShow: onShow,\n    onHide: onHide\n  }),\n      show = _useModelToggle.show,\n      hide = _useModelToggle.hide;\n\n  var _useTimeout = useTimeout(),\n      registerTimeout = _useTimeout.registerTimeout,\n      cancelTimeout = _useTimeout.cancelTimeout;\n\n  function onShow() {\n    popperStyle.value.zIndex = PopupManager.nextZIndex();\n    nextTick(initializePopper);\n  }\n\n  function onHide() {\n    hideTeleport();\n    nextTick(detachPopper);\n  }\n\n  function delayShow() {\n    if (isManual.value || props.disabled) return;\n    showTeleport();\n    registerTimeout(show, props.showAfter);\n  }\n\n  function delayHide() {\n    if (isManual.value) return;\n    registerTimeout(hide, props.hideAfter);\n  }\n\n  function onToggle() {\n    if (visible.value) {\n      delayShow();\n    } else {\n      delayHide();\n    }\n  }\n\n  function detachPopper() {\n    var _a2;\n\n    (_a2 = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a2.call(popperInstance);\n    popperInstance = null;\n  }\n\n  function onPopperMouseEnter() {\n    if (props.enterable && props.trigger !== \"click\") {\n      cancelTimeout();\n    }\n  }\n\n  function onPopperMouseLeave() {\n    var trigger = props.trigger;\n    var shouldPrevent = isString(trigger) && (trigger === \"click\" || trigger === \"focus\") || trigger.length === 1 && (trigger[0] === \"click\" || trigger[0] === \"focus\");\n    if (shouldPrevent) return;\n    delayHide();\n  }\n\n  function initializePopper() {\n    if (!visible.value || popperInstance !== null) {\n      return;\n    }\n\n    var unwrappedTrigger = triggerRef.value;\n    var $el = isHTMLElement(unwrappedTrigger) ? unwrappedTrigger : unwrappedTrigger.$el;\n    popperInstance = createPopper($el, popperRef.value, buildPopperOptions());\n    popperInstance.update();\n  }\n\n  function buildPopperOptions() {\n    var modifiers = [].concat(_toConsumableArray(defaultModifiers), _toConsumableArray(props.popperOptions.modifiers));\n\n    if (props.showArrow) {\n      modifiers.push({\n        name: \"arrow\",\n        options: {\n          padding: props.arrowOffset || 5,\n          element: arrowRef.value\n        }\n      });\n    }\n\n    return _objectSpread(_objectSpread({}, props.popperOptions), {}, {\n      modifiers: modifiers\n    });\n  }\n\n  var _useTransitionFallthr = useTransitionFallthrough(),\n      onAfterEnter = _useTransitionFallthr.onAfterEnter,\n      onAfterLeave = _useTransitionFallthr.onAfterLeave,\n      onBeforeEnter = _useTransitionFallthr.onBeforeEnter,\n      onBeforeLeave = _useTransitionFallthr.onBeforeLeave;\n\n  var events = useTargetEvents(delayShow, delayHide, onToggle);\n  var arrowRefAttacher = refAttacher(arrowRef);\n  var popperRefAttacher = refAttacher(popperRef);\n  var triggerRefAttacher = refAttacher(triggerRef);\n\n  function popupRenderer() {\n    var mouseUpAndDown = props.stopPopperMouseEvent ? stop : NOOP;\n    return h(Transition, {\n      name: props.transition,\n      onAfterEnter: onAfterEnter,\n      onAfterLeave: onAfterLeave,\n      onBeforeEnter: onBeforeEnter,\n      onBeforeLeave: onBeforeLeave\n    }, {\n      \"default\": function _default() {\n        return function () {\n          return visible.value ? h(\"div\", {\n            \"aria-hidden\": false,\n            \"class\": [props.popperClass, \"el-popper\", \"is-\".concat(props.effect), props.pure ? \"is-pure\" : \"\"],\n            style: popperStyle.value,\n            id: popperId,\n            ref: popperRefAttacher,\n            role: \"tooltip\",\n            onMouseenter: onPopperMouseEnter,\n            onMouseleave: onPopperMouseLeave,\n            onClick: stop,\n            onMousedown: mouseUpAndDown,\n            onMouseup: mouseUpAndDown\n          }, [renderSlot(slots, \"default\", {}, function () {\n            return [toDisplayString(props.content)];\n          }), arrowRenderer()]) : null;\n        };\n      }\n    });\n  }\n\n  function arrowRenderer() {\n    return props.showArrow ? h(\"div\", {\n      ref: arrowRefAttacher,\n      \"class\": \"el-popper__arrow\",\n      \"data-popper-arrow\": \"\"\n    }, null) : null;\n  }\n\n  function triggerRenderer(triggerProps) {\n    var _a2;\n\n    var trigger = (_a2 = slots.trigger) == null ? void 0 : _a2.call(slots);\n    var firstElement = getFirstValidNode(trigger, 1);\n    if (!firstElement) throwError(\"renderTrigger\", \"trigger expects single rooted node\");\n    return cloneVNode(firstElement, triggerProps, true);\n  }\n\n  function render() {\n    var trigger = triggerRenderer(_objectSpread({\n      \"aria-describedby\": popperId,\n      \"class\": props[\"class\"],\n      style: props.style,\n      ref: triggerRefAttacher\n    }, events));\n    return h(Fragment, null, [isManual.value ? trigger : withDirectives(trigger, [[ClickOutside, delayHide]]), renderTeleport()]);\n  }\n\n  return {\n    render: render\n  };\n};\n\nexport { DARK_EFFECT, LIGHT_EFFECT, usePopperControlProps, usePopperHook, usePopperProps };","map":null,"metadata":{},"sourceType":"module"}