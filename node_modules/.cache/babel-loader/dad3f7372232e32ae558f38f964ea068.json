{"ast":null,"code":"var _registerRuntimeHelpe, _DOMErrorMessages;\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { registerRuntimeHelpers, isBuiltInType, createSimpleExpression, createCompilerError, createObjectProperty, createCallExpression, TO_DISPLAY_STRING, transformModel as transformModel$1, findProp, hasDynamicKeyVBind, transformOn as transformOn$1, createCompoundExpression, isStaticExp, checkCompatEnabled, noopDirectiveTransform, baseCompile, baseParse } from '@vue/compiler-core';\nexport * from '@vue/compiler-core';\nimport { isVoidTag, isHTMLTag, isSVGTag, makeMap, parseStringStyle, capitalize, extend } from '@vue/shared';\nvar V_MODEL_RADIO = Symbol(process.env.NODE_ENV !== 'production' ? \"vModelRadio\" : \"\");\nvar V_MODEL_CHECKBOX = Symbol(process.env.NODE_ENV !== 'production' ? \"vModelCheckbox\" : \"\");\nvar V_MODEL_TEXT = Symbol(process.env.NODE_ENV !== 'production' ? \"vModelText\" : \"\");\nvar V_MODEL_SELECT = Symbol(process.env.NODE_ENV !== 'production' ? \"vModelSelect\" : \"\");\nvar V_MODEL_DYNAMIC = Symbol(process.env.NODE_ENV !== 'production' ? \"vModelDynamic\" : \"\");\nvar V_ON_WITH_MODIFIERS = Symbol(process.env.NODE_ENV !== 'production' ? \"vOnModifiersGuard\" : \"\");\nvar V_ON_WITH_KEYS = Symbol(process.env.NODE_ENV !== 'production' ? \"vOnKeysGuard\" : \"\");\nvar V_SHOW = Symbol(process.env.NODE_ENV !== 'production' ? \"vShow\" : \"\");\nvar TRANSITION = Symbol(process.env.NODE_ENV !== 'production' ? \"Transition\" : \"\");\nvar TRANSITION_GROUP = Symbol(process.env.NODE_ENV !== 'production' ? \"TransitionGroup\" : \"\");\nregisterRuntimeHelpers((_registerRuntimeHelpe = {}, _defineProperty(_registerRuntimeHelpe, V_MODEL_RADIO, \"vModelRadio\"), _defineProperty(_registerRuntimeHelpe, V_MODEL_CHECKBOX, \"vModelCheckbox\"), _defineProperty(_registerRuntimeHelpe, V_MODEL_TEXT, \"vModelText\"), _defineProperty(_registerRuntimeHelpe, V_MODEL_SELECT, \"vModelSelect\"), _defineProperty(_registerRuntimeHelpe, V_MODEL_DYNAMIC, \"vModelDynamic\"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_MODIFIERS, \"withModifiers\"), _defineProperty(_registerRuntimeHelpe, V_ON_WITH_KEYS, \"withKeys\"), _defineProperty(_registerRuntimeHelpe, V_SHOW, \"vShow\"), _defineProperty(_registerRuntimeHelpe, TRANSITION, \"Transition\"), _defineProperty(_registerRuntimeHelpe, TRANSITION_GROUP, \"TransitionGroup\"), _registerRuntimeHelpe));\n/* eslint-disable no-restricted-globals */\n\nvar decoder;\n\nfunction decodeHtmlBrowser(raw) {\n  var asAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (!decoder) {\n    decoder = document.createElement('div');\n  }\n\n  if (asAttr) {\n    decoder.innerHTML = \"<div foo=\\\"\".concat(raw.replace(/\"/g, '&quot;'), \"\\\">\");\n    return decoder.children[0].getAttribute('foo');\n  } else {\n    decoder.innerHTML = raw;\n    return decoder.textContent;\n  }\n}\n\nvar isRawTextContainer = /*#__PURE__*/makeMap('style,iframe,script,noscript', true);\nvar parserOptions = {\n  isVoidTag: isVoidTag,\n  isNativeTag: function isNativeTag(tag) {\n    return isHTMLTag(tag) || isSVGTag(tag);\n  },\n  isPreTag: function isPreTag(tag) {\n    return tag === 'pre';\n  },\n  decodeEntities: decodeHtmlBrowser,\n  isBuiltInComponent: function isBuiltInComponent(tag) {\n    if (isBuiltInType(tag, \"Transition\")) {\n      return TRANSITION;\n    } else if (isBuiltInType(tag, \"TransitionGroup\")) {\n      return TRANSITION_GROUP;\n    }\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace: function getNamespace(tag, parent) {\n    var ns = parent ? parent.ns : 0\n    /* HTML */\n    ;\n\n    if (parent && ns === 2\n    /* MATH_ML */\n    ) {\n      if (parent.tag === 'annotation-xml') {\n        if (tag === 'svg') {\n          return 1\n          /* SVG */\n          ;\n        }\n\n        if (parent.props.some(function (a) {\n          return a.type === 6\n          /* ATTRIBUTE */\n          && a.name === 'encoding' && a.value != null && (a.value.content === 'text/html' || a.value.content === 'application/xhtml+xml');\n        })) {\n          ns = 0\n          /* HTML */\n          ;\n        }\n      } else if (/^m(?:[ions]|text)$/.test(parent.tag) && tag !== 'mglyph' && tag !== 'malignmark') {\n        ns = 0\n        /* HTML */\n        ;\n      }\n    } else if (parent && ns === 1\n    /* SVG */\n    ) {\n      if (parent.tag === 'foreignObject' || parent.tag === 'desc' || parent.tag === 'title') {\n        ns = 0\n        /* HTML */\n        ;\n      }\n    }\n\n    if (ns === 0\n    /* HTML */\n    ) {\n      if (tag === 'svg') {\n        return 1\n        /* SVG */\n        ;\n      }\n\n      if (tag === 'math') {\n        return 2\n        /* MATH_ML */\n        ;\n      }\n    }\n\n    return ns;\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments\n  getTextMode: function getTextMode(_ref) {\n    var tag = _ref.tag,\n        ns = _ref.ns;\n\n    if (ns === 0\n    /* HTML */\n    ) {\n      if (tag === 'textarea' || tag === 'title') {\n        return 1\n        /* RCDATA */\n        ;\n      }\n\n      if (isRawTextContainer(tag)) {\n        return 2\n        /* RAWTEXT */\n        ;\n      }\n    }\n\n    return 0\n    /* DATA */\n    ;\n  }\n}; // Parse inline CSS strings for static style attributes into an object.\n// This is a NodeTransform since it works on the static `style` attribute and\n// converts it into a dynamic equivalent:\n// style=\"color: red\" -> :style='{ \"color\": \"red\" }'\n// It is then processed by `transformElement` and included in the generated\n// props.\n\nvar transformStyle = function transformStyle(node) {\n  if (node.type === 1\n  /* ELEMENT */\n  ) {\n    node.props.forEach(function (p, i) {\n      if (p.type === 6\n      /* ATTRIBUTE */\n      && p.name === 'style' && p.value) {\n        // replace p with an expression node\n        node.props[i] = {\n          type: 7\n          /* DIRECTIVE */\n          ,\n          name: \"bind\",\n          arg: createSimpleExpression(\"style\", true, p.loc),\n          exp: parseInlineCSS(p.value.content, p.loc),\n          modifiers: [],\n          loc: p.loc\n        };\n      }\n    });\n  }\n};\n\nvar parseInlineCSS = function parseInlineCSS(cssText, loc) {\n  var normalized = parseStringStyle(cssText);\n  return createSimpleExpression(JSON.stringify(normalized), false, loc, 3\n  /* CAN_STRINGIFY */\n  );\n};\n\nfunction createDOMCompilerError(code, loc) {\n  return createCompilerError(code, loc, process.env.NODE_ENV !== 'production' || !true ? DOMErrorMessages : undefined);\n}\n\nvar DOMErrorMessages = (_DOMErrorMessages = {}, _defineProperty(_DOMErrorMessages, 50\n/* X_V_HTML_NO_EXPRESSION */\n, \"v-html is missing expression.\"), _defineProperty(_DOMErrorMessages, 51\n/* X_V_HTML_WITH_CHILDREN */\n, \"v-html will override element children.\"), _defineProperty(_DOMErrorMessages, 52\n/* X_V_TEXT_NO_EXPRESSION */\n, \"v-text is missing expression.\"), _defineProperty(_DOMErrorMessages, 53\n/* X_V_TEXT_WITH_CHILDREN */\n, \"v-text will override element children.\"), _defineProperty(_DOMErrorMessages, 54\n/* X_V_MODEL_ON_INVALID_ELEMENT */\n, \"v-model can only be used on <input>, <textarea> and <select> elements.\"), _defineProperty(_DOMErrorMessages, 55\n/* X_V_MODEL_ARG_ON_ELEMENT */\n, \"v-model argument is not supported on plain elements.\"), _defineProperty(_DOMErrorMessages, 56\n/* X_V_MODEL_ON_FILE_INPUT_ELEMENT */\n, \"v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.\"), _defineProperty(_DOMErrorMessages, 57\n/* X_V_MODEL_UNNECESSARY_VALUE */\n, \"Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.\"), _defineProperty(_DOMErrorMessages, 58\n/* X_V_SHOW_NO_EXPRESSION */\n, \"v-show is missing expression.\"), _defineProperty(_DOMErrorMessages, 59\n/* X_TRANSITION_INVALID_CHILDREN */\n, \"<Transition> expects exactly one child element or component.\"), _defineProperty(_DOMErrorMessages, 60\n/* X_IGNORED_SIDE_EFFECT_TAG */\n, \"Tags with side effect (<script> and <style>) are ignored in client component templates.\"), _DOMErrorMessages);\n\nvar transformVHtml = function transformVHtml(dir, node, context) {\n  var exp = dir.exp,\n      loc = dir.loc;\n\n  if (!exp) {\n    context.onError(createDOMCompilerError(50\n    /* X_V_HTML_NO_EXPRESSION */\n    , loc));\n  }\n\n  if (node.children.length) {\n    context.onError(createDOMCompilerError(51\n    /* X_V_HTML_WITH_CHILDREN */\n    , loc));\n    node.children.length = 0;\n  }\n\n  return {\n    props: [createObjectProperty(createSimpleExpression(\"innerHTML\", true, loc), exp || createSimpleExpression('', true))]\n  };\n};\n\nvar transformVText = function transformVText(dir, node, context) {\n  var exp = dir.exp,\n      loc = dir.loc;\n\n  if (!exp) {\n    context.onError(createDOMCompilerError(52\n    /* X_V_TEXT_NO_EXPRESSION */\n    , loc));\n  }\n\n  if (node.children.length) {\n    context.onError(createDOMCompilerError(53\n    /* X_V_TEXT_WITH_CHILDREN */\n    , loc));\n    node.children.length = 0;\n  }\n\n  return {\n    props: [createObjectProperty(createSimpleExpression(\"textContent\", true), exp ? createCallExpression(context.helperString(TO_DISPLAY_STRING), [exp], loc) : createSimpleExpression('', true))]\n  };\n};\n\nvar transformModel = function transformModel(dir, node, context) {\n  var baseResult = transformModel$1(dir, node, context); // base transform has errors OR component v-model (only need props)\n\n  if (!baseResult.props.length || node.tagType === 1\n  /* COMPONENT */\n  ) {\n    return baseResult;\n  }\n\n  if (dir.arg) {\n    context.onError(createDOMCompilerError(55\n    /* X_V_MODEL_ARG_ON_ELEMENT */\n    , dir.arg.loc));\n  }\n\n  function checkDuplicatedValue() {\n    var value = findProp(node, 'value');\n\n    if (value) {\n      context.onError(createDOMCompilerError(57\n      /* X_V_MODEL_UNNECESSARY_VALUE */\n      , value.loc));\n    }\n  }\n\n  var tag = node.tag;\n  var isCustomElement = context.isCustomElement(tag);\n\n  if (tag === 'input' || tag === 'textarea' || tag === 'select' || isCustomElement) {\n    var directiveToUse = V_MODEL_TEXT;\n    var isInvalidType = false;\n\n    if (tag === 'input' || isCustomElement) {\n      var type = findProp(node, \"type\");\n\n      if (type) {\n        if (type.type === 7\n        /* DIRECTIVE */\n        ) {\n          // :type=\"foo\"\n          directiveToUse = V_MODEL_DYNAMIC;\n        } else if (type.value) {\n          switch (type.value.content) {\n            case 'radio':\n              directiveToUse = V_MODEL_RADIO;\n              break;\n\n            case 'checkbox':\n              directiveToUse = V_MODEL_CHECKBOX;\n              break;\n\n            case 'file':\n              isInvalidType = true;\n              context.onError(createDOMCompilerError(56\n              /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */\n              , dir.loc));\n              break;\n\n            default:\n              // text type\n              process.env.NODE_ENV !== 'production' && checkDuplicatedValue();\n              break;\n          }\n        }\n      } else if (hasDynamicKeyVBind(node)) {\n        // element has bindings with dynamic keys, which can possibly contain\n        // \"type\".\n        directiveToUse = V_MODEL_DYNAMIC;\n      } else {\n        // text type\n        process.env.NODE_ENV !== 'production' && checkDuplicatedValue();\n      }\n    } else if (tag === 'select') {\n      directiveToUse = V_MODEL_SELECT;\n    } else {\n      // textarea\n      process.env.NODE_ENV !== 'production' && checkDuplicatedValue();\n    } // inject runtime directive\n    // by returning the helper symbol via needRuntime\n    // the import will replaced a resolveDirective call.\n\n\n    if (!isInvalidType) {\n      baseResult.needRuntime = context.helper(directiveToUse);\n    }\n  } else {\n    context.onError(createDOMCompilerError(54\n    /* X_V_MODEL_ON_INVALID_ELEMENT */\n    , dir.loc));\n  } // native vmodel doesn't need the `modelValue` props since they are also\n  // passed to the runtime as `binding.value`. removing it reduces code size.\n\n\n  baseResult.props = baseResult.props.filter(function (p) {\n    return !(p.key.type === 4\n    /* SIMPLE_EXPRESSION */\n    && p.key.content === 'modelValue');\n  });\n  return baseResult;\n};\n\nvar isEventOptionModifier = /*#__PURE__*/makeMap(\"passive,once,capture\");\nvar isNonKeyModifier = /*#__PURE__*/makeMap( // event propagation management\n\"stop,prevent,self,\" + // system modifiers + exact\n\"ctrl,shift,alt,meta,exact,\" + // mouse\n\"middle\"); // left & right could be mouse or key modifiers based on event type\n\nvar maybeKeyModifier = /*#__PURE__*/makeMap('left,right');\nvar isKeyboardEvent = /*#__PURE__*/makeMap(\"onkeyup,onkeydown,onkeypress\", true);\n\nvar resolveModifiers = function resolveModifiers(key, modifiers, context, loc) {\n  var keyModifiers = [];\n  var nonKeyModifiers = [];\n  var eventOptionModifiers = [];\n\n  for (var i = 0; i < modifiers.length; i++) {\n    var modifier = modifiers[i];\n\n    if (modifier === 'native' && checkCompatEnabled(\"COMPILER_V_ON_NATIVE\"\n    /* COMPILER_V_ON_NATIVE */\n    , context, loc)) {\n      eventOptionModifiers.push(modifier);\n    } else if (isEventOptionModifier(modifier)) {\n      // eventOptionModifiers: modifiers for addEventListener() options,\n      // e.g. .passive & .capture\n      eventOptionModifiers.push(modifier);\n    } else {\n      // runtimeModifiers: modifiers that needs runtime guards\n      if (maybeKeyModifier(modifier)) {\n        if (isStaticExp(key)) {\n          if (isKeyboardEvent(key.content)) {\n            keyModifiers.push(modifier);\n          } else {\n            nonKeyModifiers.push(modifier);\n          }\n        } else {\n          keyModifiers.push(modifier);\n          nonKeyModifiers.push(modifier);\n        }\n      } else {\n        if (isNonKeyModifier(modifier)) {\n          nonKeyModifiers.push(modifier);\n        } else {\n          keyModifiers.push(modifier);\n        }\n      }\n    }\n  }\n\n  return {\n    keyModifiers: keyModifiers,\n    nonKeyModifiers: nonKeyModifiers,\n    eventOptionModifiers: eventOptionModifiers\n  };\n};\n\nvar transformClick = function transformClick(key, event) {\n  var isStaticClick = isStaticExp(key) && key.content.toLowerCase() === 'onclick';\n  return isStaticClick ? createSimpleExpression(event, true) : key.type !== 4\n  /* SIMPLE_EXPRESSION */\n  ? createCompoundExpression([\"(\", key, \") === \\\"onClick\\\" ? \\\"\".concat(event, \"\\\" : (\"), key, \")\"]) : key;\n};\n\nvar transformOn = function transformOn(dir, node, context) {\n  return transformOn$1(dir, node, context, function (baseResult) {\n    var modifiers = dir.modifiers;\n    if (!modifiers.length) return baseResult;\n    var _baseResult$props$ = baseResult.props[0],\n        key = _baseResult$props$.key,\n        handlerExp = _baseResult$props$.value;\n\n    var _resolveModifiers = resolveModifiers(key, modifiers, context, dir.loc),\n        keyModifiers = _resolveModifiers.keyModifiers,\n        nonKeyModifiers = _resolveModifiers.nonKeyModifiers,\n        eventOptionModifiers = _resolveModifiers.eventOptionModifiers; // normalize click.right and click.middle since they don't actually fire\n\n\n    if (nonKeyModifiers.includes('right')) {\n      key = transformClick(key, \"onContextmenu\");\n    }\n\n    if (nonKeyModifiers.includes('middle')) {\n      key = transformClick(key, \"onMouseup\");\n    }\n\n    if (nonKeyModifiers.length) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_MODIFIERS), [handlerExp, JSON.stringify(nonKeyModifiers)]);\n    }\n\n    if (keyModifiers.length && ( // if event name is dynamic, always wrap with keys guard\n    !isStaticExp(key) || isKeyboardEvent(key.content))) {\n      handlerExp = createCallExpression(context.helper(V_ON_WITH_KEYS), [handlerExp, JSON.stringify(keyModifiers)]);\n    }\n\n    if (eventOptionModifiers.length) {\n      var modifierPostfix = eventOptionModifiers.map(capitalize).join('');\n      key = isStaticExp(key) ? createSimpleExpression(\"\".concat(key.content).concat(modifierPostfix), true) : createCompoundExpression([\"(\", key, \") + \\\"\".concat(modifierPostfix, \"\\\"\")]);\n    }\n\n    return {\n      props: [createObjectProperty(key, handlerExp)]\n    };\n  });\n};\n\nvar transformShow = function transformShow(dir, node, context) {\n  var exp = dir.exp,\n      loc = dir.loc;\n\n  if (!exp) {\n    context.onError(createDOMCompilerError(58\n    /* X_V_SHOW_NO_EXPRESSION */\n    , loc));\n  }\n\n  return {\n    props: [],\n    needRuntime: context.helper(V_SHOW)\n  };\n};\n\nvar warnTransitionChildren = function warnTransitionChildren(node, context) {\n  if (node.type === 1\n  /* ELEMENT */\n  && node.tagType === 1\n  /* COMPONENT */\n  ) {\n    var component = context.isBuiltInComponent(node.tag);\n\n    if (component === TRANSITION) {\n      return function () {\n        if (node.children.length && hasMultipleChildren(node)) {\n          context.onError(createDOMCompilerError(59\n          /* X_TRANSITION_INVALID_CHILDREN */\n          , {\n            start: node.children[0].loc.start,\n            end: node.children[node.children.length - 1].loc.end,\n            source: ''\n          }));\n        }\n      };\n    }\n  }\n};\n\nfunction hasMultipleChildren(node) {\n  // #1352 filter out potential comment nodes.\n  var children = node.children = node.children.filter(function (c) {\n    return c.type !== 3\n    /* COMMENT */\n    && !(c.type === 2\n    /* TEXT */\n    && !c.content.trim());\n  });\n  var child = children[0];\n  return children.length !== 1 || child.type === 11\n  /* FOR */\n  || child.type === 9\n  /* IF */\n  && child.branches.some(hasMultipleChildren);\n}\n\nvar ignoreSideEffectTags = function ignoreSideEffectTags(node, context) {\n  if (node.type === 1\n  /* ELEMENT */\n  && node.tagType === 0\n  /* ELEMENT */\n  && (node.tag === 'script' || node.tag === 'style')) {\n    context.onError(createDOMCompilerError(60\n    /* X_IGNORED_SIDE_EFFECT_TAG */\n    , node.loc));\n    context.removeNode();\n  }\n};\n\nvar DOMNodeTransforms = [transformStyle].concat(_toConsumableArray(process.env.NODE_ENV !== 'production' ? [warnTransitionChildren] : []));\nvar DOMDirectiveTransforms = {\n  cloak: noopDirectiveTransform,\n  html: transformVHtml,\n  text: transformVText,\n  model: transformModel,\n  on: transformOn,\n  show: transformShow\n};\n\nfunction compile(template) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return baseCompile(template, extend({}, parserOptions, options, {\n    nodeTransforms: [// ignore <script> and <tag>\n    // this is not put inside DOMNodeTransforms because that list is used\n    // by compiler-ssr to generate vnode fallback branches\n    ignoreSideEffectTags].concat(_toConsumableArray(DOMNodeTransforms), _toConsumableArray(options.nodeTransforms || [])),\n    directiveTransforms: extend({}, DOMDirectiveTransforms, options.directiveTransforms || {}),\n    transformHoist: null\n  }));\n}\n\nfunction parse(template) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return baseParse(template, extend({}, parserOptions, options));\n}\n\nexport { DOMDirectiveTransforms, DOMNodeTransforms, TRANSITION, TRANSITION_GROUP, V_MODEL_CHECKBOX, V_MODEL_DYNAMIC, V_MODEL_RADIO, V_MODEL_SELECT, V_MODEL_TEXT, V_ON_WITH_KEYS, V_ON_WITH_MODIFIERS, V_SHOW, compile, createDOMCompilerError, parse, parserOptions, transformStyle };","map":null,"metadata":{},"sourceType":"module"}