{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { ref, computed, inject, nextTick, watch } from 'vue';\nimport debounce from 'lodash/debounce';\nimport { UPDATE_MODEL_EVENT } from '../../../utils/constants.mjs';\nimport { on, off } from '../../../utils/dom.mjs';\n\nvar useTooltip = function useTooltip(props, formatTooltip, showTooltip) {\n  var tooltip = ref(null);\n  var tooltipVisible = ref(false);\n  var enableFormat = computed(function () {\n    return formatTooltip.value instanceof Function;\n  });\n  var formatValue = computed(function () {\n    return enableFormat.value && formatTooltip.value(props.modelValue) || props.modelValue;\n  });\n  var displayTooltip = debounce(function () {\n    showTooltip.value && (tooltipVisible.value = true);\n  }, 50);\n  var hideTooltip = debounce(function () {\n    showTooltip.value && (tooltipVisible.value = false);\n  }, 50);\n  return {\n    tooltip: tooltip,\n    tooltipVisible: tooltipVisible,\n    formatValue: formatValue,\n    displayTooltip: displayTooltip,\n    hideTooltip: hideTooltip\n  };\n};\n\nvar useSliderButton = function useSliderButton(props, initData, emit) {\n  var _inject = inject(\"SliderProvider\"),\n      disabled = _inject.disabled,\n      min = _inject.min,\n      max = _inject.max,\n      step = _inject.step,\n      showTooltip = _inject.showTooltip,\n      precision = _inject.precision,\n      sliderSize = _inject.sliderSize,\n      formatTooltip = _inject.formatTooltip,\n      emitChange = _inject.emitChange,\n      resetSize = _inject.resetSize,\n      updateDragging = _inject.updateDragging;\n\n  var _useTooltip = useTooltip(props, formatTooltip, showTooltip),\n      tooltip = _useTooltip.tooltip,\n      tooltipVisible = _useTooltip.tooltipVisible,\n      formatValue = _useTooltip.formatValue,\n      displayTooltip = _useTooltip.displayTooltip,\n      hideTooltip = _useTooltip.hideTooltip;\n\n  var currentPosition = computed(function () {\n    return \"\".concat((props.modelValue - min.value) / (max.value - min.value) * 100, \"%\");\n  });\n  var wrapperStyle = computed(function () {\n    return props.vertical ? {\n      bottom: currentPosition.value\n    } : {\n      left: currentPosition.value\n    };\n  });\n\n  var handleMouseEnter = function handleMouseEnter() {\n    initData.hovering = true;\n    displayTooltip();\n  };\n\n  var handleMouseLeave = function handleMouseLeave() {\n    initData.hovering = false;\n\n    if (!initData.dragging) {\n      hideTooltip();\n    }\n  };\n\n  var onButtonDown = function onButtonDown(event) {\n    if (disabled.value) return;\n    event.preventDefault();\n    onDragStart(event);\n    on(window, \"mousemove\", onDragging);\n    on(window, \"touchmove\", onDragging);\n    on(window, \"mouseup\", onDragEnd);\n    on(window, \"touchend\", onDragEnd);\n    on(window, \"contextmenu\", onDragEnd);\n  };\n\n  var onLeftKeyDown = function onLeftKeyDown() {\n    if (disabled.value) return;\n    initData.newPosition = parseFloat(currentPosition.value) - step.value / (max.value - min.value) * 100;\n    setPosition(initData.newPosition);\n    emitChange();\n  };\n\n  var onRightKeyDown = function onRightKeyDown() {\n    if (disabled.value) return;\n    initData.newPosition = parseFloat(currentPosition.value) + step.value / (max.value - min.value) * 100;\n    setPosition(initData.newPosition);\n    emitChange();\n  };\n\n  var getClientXY = function getClientXY(event) {\n    var clientX;\n    var clientY;\n\n    if (event.type.startsWith(\"touch\")) {\n      clientY = event.touches[0].clientY;\n      clientX = event.touches[0].clientX;\n    } else {\n      clientY = event.clientY;\n      clientX = event.clientX;\n    }\n\n    return {\n      clientX: clientX,\n      clientY: clientY\n    };\n  };\n\n  var onDragStart = function onDragStart(event) {\n    initData.dragging = true;\n    initData.isClick = true;\n\n    var _getClientXY = getClientXY(event),\n        clientX = _getClientXY.clientX,\n        clientY = _getClientXY.clientY;\n\n    if (props.vertical) {\n      initData.startY = clientY;\n    } else {\n      initData.startX = clientX;\n    }\n\n    initData.startPosition = parseFloat(currentPosition.value);\n    initData.newPosition = initData.startPosition;\n  };\n\n  var onDragging = function onDragging(event) {\n    if (initData.dragging) {\n      initData.isClick = false;\n      displayTooltip();\n      resetSize();\n      var diff;\n\n      var _getClientXY2 = getClientXY(event),\n          clientX = _getClientXY2.clientX,\n          clientY = _getClientXY2.clientY;\n\n      if (props.vertical) {\n        initData.currentY = clientY;\n        diff = (initData.startY - initData.currentY) / sliderSize.value * 100;\n      } else {\n        initData.currentX = clientX;\n        diff = (initData.currentX - initData.startX) / sliderSize.value * 100;\n      }\n\n      initData.newPosition = initData.startPosition + diff;\n      setPosition(initData.newPosition);\n    }\n  };\n\n  var onDragEnd = function onDragEnd() {\n    if (initData.dragging) {\n      setTimeout(function () {\n        initData.dragging = false;\n\n        if (!initData.hovering) {\n          hideTooltip();\n        }\n\n        if (!initData.isClick) {\n          setPosition(initData.newPosition);\n          emitChange();\n        }\n      }, 0);\n      off(window, \"mousemove\", onDragging);\n      off(window, \"touchmove\", onDragging);\n      off(window, \"mouseup\", onDragEnd);\n      off(window, \"touchend\", onDragEnd);\n      off(window, \"contextmenu\", onDragEnd);\n    }\n  };\n\n  var setPosition = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(newPosition) {\n      var lengthPerStep, steps, value;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(newPosition === null || isNaN(newPosition))) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 2:\n              if (newPosition < 0) {\n                newPosition = 0;\n              } else if (newPosition > 100) {\n                newPosition = 100;\n              }\n\n              lengthPerStep = 100 / ((max.value - min.value) / step.value);\n              steps = Math.round(newPosition / lengthPerStep);\n              value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;\n              value = parseFloat(value.toFixed(precision.value));\n              emit(UPDATE_MODEL_EVENT, value);\n\n              if (!initData.dragging && props.modelValue !== initData.oldValue) {\n                initData.oldValue = props.modelValue;\n              }\n\n              _context.next = 11;\n              return nextTick();\n\n            case 11:\n              initData.dragging && displayTooltip();\n              tooltip.value.updatePopper();\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function setPosition(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  watch(function () {\n    return initData.dragging;\n  }, function (val) {\n    updateDragging(val);\n  });\n  return {\n    tooltip: tooltip,\n    tooltipVisible: tooltipVisible,\n    showTooltip: showTooltip,\n    wrapperStyle: wrapperStyle,\n    formatValue: formatValue,\n    handleMouseEnter: handleMouseEnter,\n    handleMouseLeave: handleMouseLeave,\n    onButtonDown: onButtonDown,\n    onLeftKeyDown: onLeftKeyDown,\n    onRightKeyDown: onRightKeyDown,\n    setPosition: setPosition\n  };\n};\n\nexport { useSliderButton };","map":null,"metadata":{},"sourceType":"module"}