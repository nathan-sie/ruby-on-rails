{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { inject, reactive, ref, computed, nextTick, watch, onMounted, onBeforeMount } from 'vue';\nimport { isArray, isFunction, isObject } from '@vue/shared';\nimport isEqual from 'lodash/isEqual';\nimport debounce from 'lodash/debounce';\nimport '../../../tokens/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { CHANGE_EVENT, UPDATE_MODEL_EVENT } from '../../../utils/constants.mjs';\nimport { addResizeListener, removeResizeListener } from '../../../utils/resize-event.mjs';\nimport { useGlobalConfig, getValueByPath } from '../../../utils/util.mjs';\nimport '../../popper/index.mjs';\nimport { ArrowUp } from '@element-plus/icons';\nimport { useAllowCreate } from './useAllowCreate.mjs';\nimport { flattenOptions } from './util.mjs';\nimport { useInput } from './useInput.mjs';\nimport { useLocaleInject } from '../../../hooks/use-locale/index.mjs';\nimport { elFormKey, elFormItemKey } from '../../../tokens/form.mjs';\nimport { Effect } from '../../popper/src/use-popper/defaults.mjs';\nvar DEFAULT_INPUT_PLACEHOLDER = \"\";\nvar MINIMUM_INPUT_WIDTH = 11;\nvar TAG_BASE_WIDTH = {\n  small: 42,\n  mini: 33\n};\n\nvar useSelect = function useSelect(props, emit) {\n  var _useLocaleInject = useLocaleInject(),\n      t = _useLocaleInject.t;\n\n  var elForm = inject(elFormKey, {});\n  var elFormItem = inject(elFormItemKey, {});\n  var $ELEMENT = useGlobalConfig();\n  var states = reactive({\n    inputValue: DEFAULT_INPUT_PLACEHOLDER,\n    displayInputValue: DEFAULT_INPUT_PLACEHOLDER,\n    calculatedWidth: 0,\n    cachedPlaceholder: \"\",\n    cachedOptions: [],\n    createdOptions: [],\n    createdLabel: \"\",\n    createdSelected: false,\n    currentPlaceholder: \"\",\n    hoveringIndex: -1,\n    comboBoxHovering: false,\n    isOnComposition: false,\n    isSilentBlur: false,\n    isComposing: false,\n    inputLength: 20,\n    selectWidth: 200,\n    initialInputHeight: 0,\n    previousQuery: null,\n    previousValue: \"\",\n    query: \"\",\n    selectedLabel: \"\",\n    softFocus: false,\n    tagInMultiLine: false\n  });\n  var selectedIndex = ref(-1);\n  var popperSize = ref(-1);\n  var controlRef = ref(null);\n  var inputRef = ref(null);\n  var menuRef = ref(null);\n  var popper = ref(null);\n  var selectRef = ref(null);\n  var selectionRef = ref(null);\n  var calculatorRef = ref(null);\n  var expanded = ref(false);\n  var selectDisabled = computed(function () {\n    return props.disabled || elForm.disabled;\n  });\n  var popupHeight = computed(function () {\n    var totalHeight = filteredOptions.value.length * 34;\n    return totalHeight > props.height ? props.height : totalHeight;\n  });\n  var showClearBtn = computed(function () {\n    var hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== \"\";\n    var criteria = props.clearable && !selectDisabled.value && states.comboBoxHovering && hasValue;\n    return criteria;\n  });\n  var iconComponent = computed(function () {\n    return props.remote && props.filterable ? \"\" : ArrowUp;\n  });\n  var iconReverse = computed(function () {\n    return iconComponent.value && expanded.value ? \"is-reverse\" : \"\";\n  });\n  var debounce$1 = computed(function () {\n    return props.remote ? 300 : 0;\n  });\n  var emptyText = computed(function () {\n    var options = filteredOptions.value;\n\n    if (props.loading) {\n      return props.loadingText || t(\"el.select.loading\");\n    } else {\n      if (props.remote && states.inputValue === \"\" && options.length === 0) return false;\n\n      if (props.filterable && states.inputValue && options.length > 0) {\n        return props.noMatchText || t(\"el.select.noMatch\");\n      }\n\n      if (options.length === 0) {\n        return props.noDataText || t(\"el.select.noData\");\n      }\n    }\n\n    return null;\n  });\n  var filteredOptions = computed(function () {\n    var isValidOption = function isValidOption(o) {\n      var query = states.inputValue;\n      var containsQueryString = query ? o.label.includes(query) : true;\n      return containsQueryString;\n    };\n\n    if (props.loading) {\n      return [];\n    }\n\n    return flattenOptions(props.options.concat(states.createdOptions).map(function (v) {\n      if (isArray(v.options)) {\n        var filtered = v.options.filter(isValidOption);\n\n        if (filtered.length > 0) {\n          return _objectSpread(_objectSpread({}, v), {}, {\n            options: filtered\n          });\n        }\n      } else {\n        if (props.remote || isValidOption(v)) {\n          return v;\n        }\n      }\n\n      return null;\n    }).filter(function (v) {\n      return v !== null;\n    }));\n  });\n  var optionsAllDisabled = computed(function () {\n    return filteredOptions.value.every(function (option) {\n      return option.disabled;\n    });\n  });\n  var selectSize = computed(function () {\n    return props.size || elFormItem.size || $ELEMENT.size;\n  });\n  var collapseTagSize = computed(function () {\n    return [\"small\", \"mini\"].indexOf(selectSize.value) > -1 ? \"mini\" : \"small\";\n  });\n  var tagMaxWidth = computed(function () {\n    var select = selectionRef.value;\n    var size = collapseTagSize.value;\n    var paddingLeft = select ? parseInt(getComputedStyle(select).paddingLeft) : 0;\n    var paddingRight = select ? parseInt(getComputedStyle(select).paddingRight) : 0;\n    return states.selectWidth - paddingRight - paddingLeft - TAG_BASE_WIDTH[size];\n  });\n\n  var calculatePopperSize = function calculatePopperSize() {\n    var _a, _b, _c;\n\n    popperSize.value = ((_c = (_b = (_a = selectRef.value) == null ? void 0 : _a.getBoundingClientRect) == null ? void 0 : _b.call(_a)) == null ? void 0 : _c.width) || 200;\n  };\n\n  var inputWrapperStyle = computed(function () {\n    return {\n      width: \"\".concat(states.calculatedWidth === 0 ? MINIMUM_INPUT_WIDTH : Math.ceil(states.calculatedWidth) + MINIMUM_INPUT_WIDTH, \"px\")\n    };\n  });\n  var shouldShowPlaceholder = computed(function () {\n    if (isArray(props.modelValue)) {\n      return props.modelValue.length === 0 && !states.displayInputValue;\n    }\n\n    return props.filterable ? states.displayInputValue.length === 0 : true;\n  });\n  var currentPlaceholder = computed(function () {\n    var _placeholder = props.placeholder || t(\"el.select.placeholder\");\n\n    return props.multiple ? _placeholder : states.selectedLabel || _placeholder;\n  });\n  var popperRef = computed(function () {\n    var _a;\n\n    return (_a = popper.value) == null ? void 0 : _a.popperRef;\n  });\n  var indexRef = computed(function () {\n    if (props.multiple) {\n      var len = props.modelValue.length;\n\n      if (props.modelValue.length > 0) {\n        return filteredOptions.value.findIndex(function (o) {\n          return o.value === props.modelValue[len - 1];\n        });\n      }\n    } else {\n      if (props.modelValue) {\n        return filteredOptions.value.findIndex(function (o) {\n          return o.value === props.modelValue;\n        });\n      }\n    }\n\n    return -1;\n  });\n  var dropdownMenuVisible = computed(function () {\n    return expanded.value && emptyText.value !== false;\n  });\n\n  var _useAllowCreate = useAllowCreate(props, states),\n      createNewOption = _useAllowCreate.createNewOption,\n      removeNewOption = _useAllowCreate.removeNewOption,\n      selectNewOption = _useAllowCreate.selectNewOption,\n      clearAllNewOption = _useAllowCreate.clearAllNewOption;\n\n  var _useInput = useInput(function (e) {\n    return onInput(e);\n  }),\n      handleCompositionStart = _useInput.handleCompositionStart,\n      handleCompositionUpdate = _useInput.handleCompositionUpdate,\n      handleCompositionEnd = _useInput.handleCompositionEnd;\n\n  var focusAndUpdatePopup = function focusAndUpdatePopup() {\n    var _a, _b, _c, _d;\n\n    (_b = (_a = inputRef.value).focus) == null ? void 0 : _b.call(_a);\n    (_d = (_c = popper.value).update) == null ? void 0 : _d.call(_c);\n  };\n\n  var toggleMenu = function toggleMenu() {\n    if (props.automaticDropdown) return;\n\n    if (!selectDisabled.value) {\n      if (states.isComposing) states.softFocus = true;\n      return nextTick(function () {\n        var _a, _b;\n\n        expanded.value = !expanded.value;\n        (_b = (_a = inputRef.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);\n      });\n    }\n  };\n\n  var onInputChange = function onInputChange() {\n    if (props.filterable && states.inputValue !== states.selectedLabel) {\n      states.query = states.selectedLabel;\n    }\n\n    handleQueryChange(states.inputValue);\n    return nextTick(function () {\n      createNewOption(states.inputValue);\n    });\n  };\n\n  var debouncedOnInputChange = debounce(onInputChange, debounce$1.value);\n\n  var handleQueryChange = function handleQueryChange(val) {\n    if (states.previousQuery === val) {\n      return;\n    }\n\n    states.previousQuery = val;\n\n    if (props.filterable && isFunction(props.filterMethod)) {\n      props.filterMethod(val);\n    } else if (props.filterable && props.remote && isFunction(props.remoteMethod)) {\n      props.remoteMethod(val);\n    }\n  };\n\n  var emitChange = function emitChange(val) {\n    if (!isEqual(props.modelValue, val)) {\n      emit(CHANGE_EVENT, val);\n    }\n  };\n\n  var update = function update(val) {\n    emit(UPDATE_MODEL_EVENT, val);\n    emitChange(val);\n    states.previousValue = val.toString();\n  };\n\n  var getValueIndex = function getValueIndex() {\n    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var value = arguments.length > 1 ? arguments[1] : undefined;\n\n    if (!isObject(value)) {\n      return arr.indexOf(value);\n    }\n\n    var valueKey = props.valueKey;\n    var index = -1;\n    arr.some(function (item, i) {\n      if (getValueByPath(item, valueKey) === getValueByPath(value, valueKey)) {\n        index = i;\n        return true;\n      }\n\n      return false;\n    });\n    return index;\n  };\n\n  var getValueKey = function getValueKey(item) {\n    return isObject(item) ? getValueByPath(item, props.valueKey) : item;\n  };\n\n  var getLabel = function getLabel(item) {\n    return isObject(item) ? item.label : item;\n  };\n\n  var resetInputHeight = function resetInputHeight() {\n    if (props.collapseTags && !props.filterable) {\n      return;\n    }\n\n    return nextTick(function () {\n      var _a, _b;\n\n      if (!inputRef.value) return;\n      var selection = selectionRef.value;\n      selectRef.value.height = selection.offsetHeight;\n\n      if (expanded.value && emptyText.value !== false) {\n        (_b = (_a = popper.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);\n      }\n    });\n  };\n\n  var handleResize = function handleResize() {\n    var _a, _b;\n\n    resetInputWidth();\n    calculatePopperSize();\n    (_b = (_a = popper.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);\n\n    if (props.multiple) {\n      return resetInputHeight();\n    }\n  };\n\n  var resetInputWidth = function resetInputWidth() {\n    var select = selectionRef.value;\n\n    if (select) {\n      states.selectWidth = select.getBoundingClientRect().width;\n    }\n  };\n\n  var onSelect = function onSelect(option, idx) {\n    var byClick = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    var _a, _b;\n\n    if (props.multiple) {\n      var selectedOptions = props.modelValue.slice();\n      var index = getValueIndex(selectedOptions, getValueKey(option));\n\n      if (index > -1) {\n        selectedOptions = [].concat(_toConsumableArray(selectedOptions.slice(0, index)), _toConsumableArray(selectedOptions.slice(index + 1)));\n        states.cachedOptions.splice(index, 1);\n        removeNewOption(option);\n      } else if (props.multipleLimit <= 0 || selectedOptions.length < props.multipleLimit) {\n        selectedOptions = [].concat(_toConsumableArray(selectedOptions), [getValueKey(option)]);\n        states.cachedOptions.push(option);\n        selectNewOption(option);\n        updateHoveringIndex(idx);\n      }\n\n      update(selectedOptions);\n\n      if (option.created) {\n        states.query = \"\";\n        handleQueryChange(\"\");\n        states.inputLength = 20;\n      }\n\n      if (props.filterable) {\n        (_b = (_a = inputRef.value).focus) == null ? void 0 : _b.call(_a);\n        onUpdateInputValue(\"\");\n      }\n\n      if (props.filterable) {\n        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;\n      }\n\n      resetInputHeight();\n      setSoftFocus();\n    } else {\n      selectedIndex.value = idx;\n      states.selectedLabel = option.label;\n      update(getValueKey(option));\n      expanded.value = false;\n      states.isComposing = false;\n      states.isSilentBlur = byClick;\n      selectNewOption(option);\n\n      if (!option.created) {\n        clearAllNewOption();\n      }\n\n      updateHoveringIndex(idx);\n    }\n  };\n\n  var deleteTag = function deleteTag(event, tag) {\n    var index = props.modelValue.indexOf(tag.value);\n\n    if (index > -1 && !selectDisabled.value) {\n      var value = [].concat(_toConsumableArray(props.modelValue.slice(0, index)), _toConsumableArray(props.modelValue.slice(index + 1)));\n      states.cachedOptions.splice(index, 1);\n      update(value);\n      emit(\"remove-tag\", tag.value);\n      states.softFocus = true;\n      removeNewOption(tag);\n      return nextTick(focusAndUpdatePopup);\n    }\n\n    event.stopPropagation();\n  };\n\n  var handleFocus = function handleFocus(event) {\n    var focused = states.isComposing;\n    states.isComposing = true;\n\n    if (!states.softFocus) {\n      if (!focused) emit(\"focus\", event);\n    } else {\n      states.softFocus = false;\n    }\n  };\n\n  var handleBlur = function handleBlur() {\n    states.softFocus = false;\n    return nextTick(function () {\n      var _a, _b;\n\n      (_b = (_a = inputRef.value) == null ? void 0 : _a.blur) == null ? void 0 : _b.call(_a);\n\n      if (calculatorRef.value) {\n        states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;\n      }\n\n      if (states.isSilentBlur) {\n        states.isSilentBlur = false;\n      } else {\n        if (states.isComposing) {\n          emit(\"blur\");\n        }\n      }\n\n      states.isComposing = false;\n    });\n  };\n\n  var handleEsc = function handleEsc() {\n    if (states.displayInputValue.length > 0) {\n      onUpdateInputValue(\"\");\n    } else {\n      expanded.value = false;\n    }\n  };\n\n  var handleDel = function handleDel(e) {\n    if (states.displayInputValue.length === 0) {\n      e.preventDefault();\n      var selected = props.modelValue.slice();\n      selected.pop();\n      removeNewOption(states.cachedOptions.pop());\n      update(selected);\n    }\n  };\n\n  var handleClear = function handleClear() {\n    var emptyValue;\n\n    if (isArray(props.modelValue)) {\n      emptyValue = [];\n    } else {\n      emptyValue = \"\";\n    }\n\n    states.softFocus = true;\n\n    if (props.multiple) {\n      states.cachedOptions = [];\n    } else {\n      states.selectedLabel = \"\";\n    }\n\n    expanded.value = false;\n    update(emptyValue);\n    emit(\"clear\");\n    clearAllNewOption();\n    return nextTick(focusAndUpdatePopup);\n  };\n\n  var onUpdateInputValue = function onUpdateInputValue(val) {\n    states.displayInputValue = val;\n    states.inputValue = val;\n  };\n\n  var onKeyboardNavigate = function onKeyboardNavigate(direction) {\n    var hoveringIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : void 0;\n    var options = filteredOptions.value;\n\n    if (![\"forward\", \"backward\"].includes(direction) || selectDisabled.value || options.length <= 0 || optionsAllDisabled.value) {\n      return;\n    }\n\n    if (!expanded.value) {\n      return toggleMenu();\n    }\n\n    if (hoveringIndex === void 0) {\n      hoveringIndex = states.hoveringIndex;\n    }\n\n    var newIndex = -1;\n\n    if (direction === \"forward\") {\n      newIndex = hoveringIndex + 1;\n\n      if (newIndex >= options.length) {\n        newIndex = 0;\n      }\n    } else if (direction === \"backward\") {\n      newIndex = hoveringIndex - 1;\n\n      if (newIndex < 0) {\n        newIndex = options.length - 1;\n      }\n    }\n\n    var option = options[newIndex];\n\n    if (option.disabled || option.type === \"Group\") {\n      return onKeyboardNavigate(direction, newIndex);\n    } else {\n      updateHoveringIndex(newIndex);\n      scrollToItem(newIndex);\n    }\n  };\n\n  var onKeyboardSelect = function onKeyboardSelect() {\n    if (!expanded.value) {\n      return toggleMenu();\n    } else if (~states.hoveringIndex) {\n      onSelect(filteredOptions.value[states.hoveringIndex], states.hoveringIndex, false);\n    }\n  };\n\n  var updateHoveringIndex = function updateHoveringIndex(idx) {\n    states.hoveringIndex = idx;\n  };\n\n  var resetHoveringIndex = function resetHoveringIndex() {\n    states.hoveringIndex = -1;\n  };\n\n  var setSoftFocus = function setSoftFocus() {\n    var _a;\n\n    var _input = inputRef.value;\n\n    if (_input) {\n      (_a = _input.focus) == null ? void 0 : _a.call(_input);\n    }\n  };\n\n  var onInput = function onInput(event) {\n    var value = event.target.value;\n    onUpdateInputValue(value);\n\n    if (states.displayInputValue.length > 0 && !expanded.value) {\n      expanded.value = true;\n    }\n\n    states.calculatedWidth = calculatorRef.value.getBoundingClientRect().width;\n\n    if (props.multiple) {\n      resetInputHeight();\n    }\n\n    if (props.remote) {\n      debouncedOnInputChange();\n    } else {\n      return onInputChange();\n    }\n  };\n\n  var handleClickOutside = function handleClickOutside() {\n    expanded.value = false;\n    return handleBlur();\n  };\n\n  var handleMenuEnter = function handleMenuEnter() {\n    states.inputValue = states.displayInputValue;\n    return nextTick(function () {\n      if (~indexRef.value) {\n        updateHoveringIndex(indexRef.value);\n        scrollToItem(states.hoveringIndex);\n      }\n    });\n  };\n\n  var scrollToItem = function scrollToItem(index) {\n    menuRef.value.scrollToItem(index);\n  };\n\n  var initStates = function initStates() {\n    resetHoveringIndex();\n\n    if (props.multiple) {\n      if (props.modelValue.length > 0) {\n        var initHovering = false;\n        states.cachedOptions.length = 0;\n        props.modelValue.map(function (selected) {\n          var itemIndex = filteredOptions.value.findIndex(function (option) {\n            return getValueKey(option) === selected;\n          });\n\n          if (~itemIndex) {\n            states.cachedOptions.push(filteredOptions.value[itemIndex]);\n\n            if (!initHovering) {\n              updateHoveringIndex(itemIndex);\n            }\n\n            initHovering = true;\n          }\n        });\n      } else {\n        states.cachedOptions = [];\n      }\n    } else {\n      if (props.modelValue) {\n        var options = filteredOptions.value;\n        var selectedItemIndex = options.findIndex(function (option) {\n          return getValueKey(option) === props.modelValue;\n        });\n\n        if (~selectedItemIndex) {\n          states.selectedLabel = options[selectedItemIndex].label;\n          updateHoveringIndex(selectedItemIndex);\n        } else {\n          states.selectedLabel = \"\".concat(props.modelValue);\n        }\n      } else {\n        states.selectedLabel = \"\";\n      }\n    }\n\n    calculatePopperSize();\n  };\n\n  watch(expanded, function (val) {\n    var _a, _b;\n\n    emit(\"visible-change\", val);\n\n    if (val) {\n      (_b = (_a = popper.value).update) == null ? void 0 : _b.call(_a);\n    } else {\n      states.displayInputValue = \"\";\n      createNewOption(\"\");\n    }\n  });\n  watch(function () {\n    return props.modelValue;\n  }, function (val) {\n    if (!val || val.toString() !== states.previousValue) {\n      initStates();\n    }\n  }, {\n    deep: true\n  });\n  watch(function () {\n    return props.options;\n  }, function () {\n    var input = inputRef.value;\n\n    if (!input || input && document.activeElement !== input) {\n      initStates();\n    }\n  }, {\n    deep: true\n  });\n  watch(filteredOptions, function () {\n    return nextTick(menuRef.value.resetScrollTop);\n  });\n  onMounted(function () {\n    initStates();\n    addResizeListener(selectRef.value, handleResize);\n  });\n  onBeforeMount(function () {\n    removeResizeListener(selectRef.value, handleResize);\n  });\n  return {\n    collapseTagSize: collapseTagSize,\n    currentPlaceholder: currentPlaceholder,\n    expanded: expanded,\n    emptyText: emptyText,\n    popupHeight: popupHeight,\n    debounce: debounce$1,\n    filteredOptions: filteredOptions,\n    iconComponent: iconComponent,\n    iconReverse: iconReverse,\n    inputWrapperStyle: inputWrapperStyle,\n    popperSize: popperSize,\n    dropdownMenuVisible: dropdownMenuVisible,\n    shouldShowPlaceholder: shouldShowPlaceholder,\n    selectDisabled: selectDisabled,\n    selectSize: selectSize,\n    showClearBtn: showClearBtn,\n    states: states,\n    tagMaxWidth: tagMaxWidth,\n    calculatorRef: calculatorRef,\n    controlRef: controlRef,\n    inputRef: inputRef,\n    menuRef: menuRef,\n    popper: popper,\n    selectRef: selectRef,\n    selectionRef: selectionRef,\n    popperRef: popperRef,\n    Effect: Effect,\n    debouncedOnInputChange: debouncedOnInputChange,\n    deleteTag: deleteTag,\n    getLabel: getLabel,\n    getValueKey: getValueKey,\n    handleBlur: handleBlur,\n    handleClear: handleClear,\n    handleClickOutside: handleClickOutside,\n    handleDel: handleDel,\n    handleEsc: handleEsc,\n    handleFocus: handleFocus,\n    handleMenuEnter: handleMenuEnter,\n    handleResize: handleResize,\n    toggleMenu: toggleMenu,\n    scrollTo: scrollToItem,\n    onInput: onInput,\n    onKeyboardNavigate: onKeyboardNavigate,\n    onKeyboardSelect: onKeyboardSelect,\n    onSelect: onSelect,\n    onHover: updateHoveringIndex,\n    onUpdateInputValue: onUpdateInputValue,\n    handleCompositionStart: handleCompositionStart,\n    handleCompositionEnd: handleCompositionEnd,\n    handleCompositionUpdate: handleCompositionUpdate\n  };\n};\n\nexport { useSelect as default };","map":null,"metadata":{},"sourceType":"module"}