{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nimport { inject, shallowRef, ref, computed, nextTick } from 'vue';\nimport { UPDATE_MODEL_EVENT, INPUT_EVENT, CHANGE_EVENT } from '../../../utils/constants.mjs';\nimport '../../../tokens/index.mjs';\nimport { elFormKey, elFormItemKey } from '../../../tokens/form.mjs';\n\nvar useSlide = function useSlide(props, initData, emit) {\n  var elForm = inject(elFormKey, {});\n  var elFormItem = inject(elFormItemKey, {});\n  var slider = shallowRef(null);\n  var firstButton = ref(null);\n  var secondButton = ref(null);\n  var buttonRefs = {\n    firstButton: firstButton,\n    secondButton: secondButton\n  };\n  var sliderDisabled = computed(function () {\n    return props.disabled || elForm.disabled || false;\n  });\n  var minValue = computed(function () {\n    return Math.min(initData.firstValue, initData.secondValue);\n  });\n  var maxValue = computed(function () {\n    return Math.max(initData.firstValue, initData.secondValue);\n  });\n  var barSize = computed(function () {\n    return props.range ? \"\".concat(100 * (maxValue.value - minValue.value) / (props.max - props.min), \"%\") : \"\".concat(100 * (initData.firstValue - props.min) / (props.max - props.min), \"%\");\n  });\n  var barStart = computed(function () {\n    return props.range ? \"\".concat(100 * (minValue.value - props.min) / (props.max - props.min), \"%\") : \"0%\";\n  });\n  var runwayStyle = computed(function () {\n    return props.vertical ? {\n      height: props.height\n    } : {};\n  });\n  var barStyle = computed(function () {\n    return props.vertical ? {\n      height: barSize.value,\n      bottom: barStart.value\n    } : {\n      width: barSize.value,\n      left: barStart.value\n    };\n  });\n\n  var resetSize = function resetSize() {\n    if (slider.value) {\n      initData.sliderSize = slider.value[\"client\".concat(props.vertical ? \"Height\" : \"Width\")];\n    }\n  };\n\n  var setPosition = function setPosition(percent) {\n    var targetValue = props.min + percent * (props.max - props.min) / 100;\n\n    if (!props.range) {\n      firstButton.value.setPosition(percent);\n      return;\n    }\n\n    var buttonRefName;\n\n    if (Math.abs(minValue.value - targetValue) < Math.abs(maxValue.value - targetValue)) {\n      buttonRefName = initData.firstValue < initData.secondValue ? \"firstButton\" : \"secondButton\";\n    } else {\n      buttonRefName = initData.firstValue > initData.secondValue ? \"firstButton\" : \"secondButton\";\n    }\n\n    buttonRefs[buttonRefName].value.setPosition(percent);\n  };\n\n  var setFirstValue = function setFirstValue(firstValue) {\n    initData.firstValue = firstValue;\n\n    _emit(props.range ? [minValue.value, maxValue.value] : firstValue);\n  };\n\n  var setSecondValue = function setSecondValue(secondValue) {\n    initData.secondValue = secondValue;\n\n    if (props.range) {\n      _emit([minValue.value, maxValue.value]);\n    }\n  };\n\n  var _emit = function _emit(val) {\n    emit(UPDATE_MODEL_EVENT, val);\n    emit(INPUT_EVENT, val);\n  };\n\n  var emitChange = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return nextTick();\n\n            case 2:\n              emit(CHANGE_EVENT, props.range ? [minValue.value, maxValue.value] : props.modelValue);\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function emitChange() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  var onSliderClick = function onSliderClick(event) {\n    if (sliderDisabled.value || initData.dragging) return;\n    resetSize();\n\n    if (props.vertical) {\n      var sliderOffsetBottom = slider.value.getBoundingClientRect().bottom;\n      setPosition((sliderOffsetBottom - event.clientY) / initData.sliderSize * 100);\n    } else {\n      var sliderOffsetLeft = slider.value.getBoundingClientRect().left;\n      setPosition((event.clientX - sliderOffsetLeft) / initData.sliderSize * 100);\n    }\n\n    emitChange();\n  };\n\n  return {\n    elFormItem: elFormItem,\n    slider: slider,\n    firstButton: firstButton,\n    secondButton: secondButton,\n    sliderDisabled: sliderDisabled,\n    minValue: minValue,\n    maxValue: maxValue,\n    runwayStyle: runwayStyle,\n    barStyle: barStyle,\n    resetSize: resetSize,\n    setPosition: setPosition,\n    emitChange: emitChange,\n    onSliderClick: onSliderClick,\n    setFirstValue: setFirstValue,\n    setSecondValue: setSecondValue\n  };\n};\n\nexport { useSlide };","map":null,"metadata":{},"sourceType":"module"}