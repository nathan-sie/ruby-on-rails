{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { defineComponent, inject, ref, getCurrentInstance, provide, watch, nextTick } from 'vue';\nimport { isFunction, isString } from '@vue/shared';\nimport _CollapseTransition from '../../collapse-transition/index.mjs';\nimport { ElCheckbox } from '../../checkbox/index.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { Loading, CaretRight } from '@element-plus/icons';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport './tree-node-content.mjs';\nimport { getNodeKey } from './model/util.mjs';\nimport { useNodeExpandEventBroadcast } from './model/useNodeExpandEventBroadcast.mjs';\nimport { dragEventsKey } from './model/useDragNode.mjs';\nimport Node from './model/node.mjs';\nimport script$1 from './tree-node-content.vue_vue&type=script&lang.mjs';\nvar script = defineComponent({\n  name: \"ElTreeNode\",\n  components: {\n    ElCollapseTransition: _CollapseTransition,\n    ElCheckbox: ElCheckbox,\n    NodeContent: script$1,\n    ElIcon: ElIcon,\n    Loading: Loading\n  },\n  props: {\n    node: {\n      type: Node,\n      \"default\": function _default() {\n        return {};\n      }\n    },\n    props: {\n      type: Object,\n      \"default\": function _default() {\n        return {};\n      }\n    },\n    accordion: Boolean,\n    renderContent: Function,\n    renderAfterExpand: Boolean,\n    showCheckbox: {\n      type: Boolean,\n      \"default\": false\n    }\n  },\n  emits: [\"node-expand\"],\n  setup: function setup(props, ctx) {\n    var _useNodeExpandEventBr = useNodeExpandEventBroadcast(props),\n        broadcastExpanded = _useNodeExpandEventBr.broadcastExpanded;\n\n    var tree = inject(\"RootTree\");\n    var expanded = ref(false);\n    var childNodeRendered = ref(false);\n    var oldChecked = ref(null);\n    var oldIndeterminate = ref(null);\n    var node$ = ref(null);\n    var dragEvents = inject(dragEventsKey);\n    var instance = getCurrentInstance();\n    provide(\"NodeInstance\", instance);\n\n    if (!tree) {\n      debugWarn(\"Tree\", \"Can not find node's tree.\");\n    }\n\n    if (props.node.expanded) {\n      expanded.value = true;\n      childNodeRendered.value = true;\n    }\n\n    var childrenKey = tree.props[\"children\"] || \"children\";\n    watch(function () {\n      var children = props.node.data[childrenKey];\n      return children && _toConsumableArray(children);\n    }, function () {\n      props.node.updateChildren();\n    });\n    watch(function () {\n      return props.node.indeterminate;\n    }, function (val) {\n      handleSelectChange(props.node.checked, val);\n    });\n    watch(function () {\n      return props.node.checked;\n    }, function (val) {\n      handleSelectChange(val, props.node.indeterminate);\n    });\n    watch(function () {\n      return props.node.expanded;\n    }, function (val) {\n      nextTick(function () {\n        return expanded.value = val;\n      });\n\n      if (val) {\n        childNodeRendered.value = true;\n      }\n    });\n\n    var getNodeKey$1 = function getNodeKey$1(node) {\n      return getNodeKey(tree.props.nodeKey, node.data);\n    };\n\n    var getNodeClass = function getNodeClass(node) {\n      var nodeClassFunc = props.props[\"class\"];\n\n      if (!nodeClassFunc) {\n        return {};\n      }\n\n      var className;\n\n      if (isFunction(nodeClassFunc)) {\n        var data = node.data;\n        className = nodeClassFunc(data, node);\n      } else {\n        className = nodeClassFunc;\n      }\n\n      if (isString(className)) {\n        return _defineProperty({}, className, true);\n      } else {\n        return className;\n      }\n    };\n\n    var handleSelectChange = function handleSelectChange(checked, indeterminate) {\n      if (oldChecked.value !== checked || oldIndeterminate.value !== indeterminate) {\n        tree.ctx.emit(\"check-change\", props.node.data, checked, indeterminate);\n      }\n\n      oldChecked.value = checked;\n      oldIndeterminate.value = indeterminate;\n    };\n\n    var handleClick = function handleClick() {\n      var store = tree.store.value;\n      store.setCurrentNode(props.node);\n      tree.ctx.emit(\"current-change\", store.currentNode ? store.currentNode.data : null, store.currentNode);\n      tree.currentNode.value = props.node;\n\n      if (tree.props.expandOnClickNode) {\n        handleExpandIconClick();\n      }\n\n      if (tree.props.checkOnClickNode && !props.node.disabled) {\n        handleCheckChange(null, {\n          target: {\n            checked: !props.node.checked\n          }\n        });\n      }\n\n      tree.ctx.emit(\"node-click\", props.node.data, props.node, instance);\n    };\n\n    var handleContextMenu = function handleContextMenu(event) {\n      if (tree.instance.vnode.props[\"onNodeContextmenu\"]) {\n        event.stopPropagation();\n        event.preventDefault();\n      }\n\n      tree.ctx.emit(\"node-contextmenu\", event, props.node.data, props.node, instance);\n    };\n\n    var handleExpandIconClick = function handleExpandIconClick() {\n      if (props.node.isLeaf) return;\n\n      if (expanded.value) {\n        tree.ctx.emit(\"node-collapse\", props.node.data, props.node, instance);\n        props.node.collapse();\n      } else {\n        props.node.expand();\n        ctx.emit(\"node-expand\", props.node.data, props.node, instance);\n      }\n    };\n\n    var handleCheckChange = function handleCheckChange(value, ev) {\n      props.node.setChecked(ev.target.checked, !tree.props.checkStrictly);\n      nextTick(function () {\n        var store = tree.store.value;\n        tree.ctx.emit(\"check\", props.node.data, {\n          checkedNodes: store.getCheckedNodes(),\n          checkedKeys: store.getCheckedKeys(),\n          halfCheckedNodes: store.getHalfCheckedNodes(),\n          halfCheckedKeys: store.getHalfCheckedKeys()\n        });\n      });\n    };\n\n    var handleChildNodeExpand = function handleChildNodeExpand(nodeData, node, instance2) {\n      broadcastExpanded(node);\n      tree.ctx.emit(\"node-expand\", nodeData, node, instance2);\n    };\n\n    var handleDragStart = function handleDragStart(event) {\n      if (!tree.props.draggable) return;\n      dragEvents.treeNodeDragStart({\n        event: event,\n        treeNode: props\n      });\n    };\n\n    var handleDragOver = function handleDragOver(event) {\n      if (!tree.props.draggable) return;\n      dragEvents.treeNodeDragOver({\n        event: event,\n        treeNode: {\n          $el: node$.value,\n          node: props.node\n        }\n      });\n      event.preventDefault();\n    };\n\n    var handleDrop = function handleDrop(event) {\n      event.preventDefault();\n    };\n\n    var handleDragEnd = function handleDragEnd(event) {\n      if (!tree.props.draggable) return;\n      dragEvents.treeNodeDragEnd(event);\n    };\n\n    return {\n      node$: node$,\n      tree: tree,\n      expanded: expanded,\n      childNodeRendered: childNodeRendered,\n      oldChecked: oldChecked,\n      oldIndeterminate: oldIndeterminate,\n      getNodeKey: getNodeKey$1,\n      getNodeClass: getNodeClass,\n      handleSelectChange: handleSelectChange,\n      handleClick: handleClick,\n      handleContextMenu: handleContextMenu,\n      handleExpandIconClick: handleExpandIconClick,\n      handleCheckChange: handleCheckChange,\n      handleChildNodeExpand: handleChildNodeExpand,\n      handleDragStart: handleDragStart,\n      handleDragOver: handleDragOver,\n      handleDrop: handleDrop,\n      handleDragEnd: handleDragEnd,\n      CaretRight: CaretRight\n    };\n  }\n});\nexport { script as default };","map":null,"metadata":{},"sourceType":"module"}