{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { isVNode, createVNode, render } from 'vue';\nimport isServer from '../../../utils/isServer.mjs';\nimport PopupManager from '../../../utils/popup-manager.mjs';\nimport '../../../utils/util.mjs';\nimport { debugWarn } from '../../../utils/error.mjs';\nimport './notification2.mjs';\nimport { notificationTypes } from './notification.mjs';\nimport script from './notification.vue_vue&type=script&lang.mjs';\nvar notifications = {\n  \"top-left\": [],\n  \"top-right\": [],\n  \"bottom-left\": [],\n  \"bottom-right\": []\n};\nvar GAP_SIZE = 16;\nvar seed = 1;\n\nvar notify = function notify() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  if (isServer) return {\n    close: function close() {\n      return void 0;\n    }\n  };\n\n  if (typeof options === \"string\" || isVNode(options)) {\n    options = {\n      message: options\n    };\n  }\n\n  var position = options.position || \"top-right\";\n  var verticalOffset = options.offset || 0;\n  notifications[position].forEach(function (_ref) {\n    var vm2 = _ref.vm;\n\n    var _a;\n\n    verticalOffset += (((_a = vm2.el) == null ? void 0 : _a.offsetHeight) || 0) + GAP_SIZE;\n  });\n  verticalOffset += GAP_SIZE;\n  var id = \"notification_\".concat(seed++);\n  var userOnClose = options.onClose;\n\n  var props = _objectSpread(_objectSpread({\n    zIndex: PopupManager.nextZIndex(),\n    offset: verticalOffset\n  }, options), {}, {\n    id: id,\n    onClose: function onClose() {\n      close(id, position, userOnClose);\n    }\n  });\n\n  var appendTo = document.body;\n\n  if (options.appendTo instanceof HTMLElement) {\n    appendTo = options.appendTo;\n  } else if (typeof options.appendTo === \"string\") {\n    appendTo = document.querySelector(options.appendTo);\n  }\n\n  if (!(appendTo instanceof HTMLElement)) {\n    debugWarn(\"ElNotification\", \"the appendTo option is not an HTMLElement. Falling back to document.body.\");\n    appendTo = document.body;\n  }\n\n  var container = document.createElement(\"div\");\n  var vm = createVNode(script, props, isVNode(props.message) ? {\n    \"default\": function _default() {\n      return props.message;\n    }\n  } : null);\n\n  vm.props.onDestroy = function () {\n    render(null, container);\n  };\n\n  render(vm, container);\n  notifications[position].push({\n    vm: vm\n  });\n  appendTo.appendChild(container.firstElementChild);\n  return {\n    close: function close() {\n      ;\n      vm.component.proxy.visible = false;\n    }\n  };\n};\n\nnotificationTypes.forEach(function (type) {\n  notify[type] = function () {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (typeof options === \"string\" || isVNode(options)) {\n      options = {\n        message: options\n      };\n    }\n\n    return notify(_objectSpread(_objectSpread({}, options), {}, {\n      type: type\n    }));\n  };\n});\n\nfunction close(id, position, userOnClose) {\n  var orientedNotifications = notifications[position];\n  var idx = orientedNotifications.findIndex(function (_ref2) {\n    var vm2 = _ref2.vm;\n\n    var _a;\n\n    return ((_a = vm2.component) == null ? void 0 : _a.props.id) === id;\n  });\n  if (idx === -1) return;\n  var vm = orientedNotifications[idx].vm;\n  if (!vm) return;\n  userOnClose == null ? void 0 : userOnClose(vm);\n  var removedHeight = vm.el.offsetHeight;\n  var verticalPos = position.split(\"-\")[0];\n  orientedNotifications.splice(idx, 1);\n  var len = orientedNotifications.length;\n  if (len < 1) return;\n\n  for (var i = idx; i < len; i++) {\n    var _orientedNotification = orientedNotifications[i].vm,\n        el = _orientedNotification.el,\n        component = _orientedNotification.component;\n    var pos = parseInt(el.style[verticalPos], 10) - removedHeight - GAP_SIZE;\n    component.props.offset = pos;\n  }\n}\n\nfunction closeAll() {\n  for (var _i = 0, _Object$values = Object.values(notifications); _i < _Object$values.length; _i++) {\n    var orientedNotifications = _Object$values[_i];\n    orientedNotifications.forEach(function (_ref3) {\n      var vm = _ref3.vm;\n      ;\n      vm.component.proxy.visible = false;\n    });\n  }\n}\n\nnotify.closeAll = closeAll;\nexport { close, closeAll, notify as default };","map":null,"metadata":{},"sourceType":"module"}