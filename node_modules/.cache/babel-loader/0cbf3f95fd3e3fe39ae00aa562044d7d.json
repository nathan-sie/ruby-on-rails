{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { defineComponent, reactive, computed, toRefs, provide, watch, ref, onMounted, nextTick, onBeforeUnmount } from 'vue';\nimport { ElInputNumber } from '../../input-number/index.mjs';\nimport { UPDATE_MODEL_EVENT, CHANGE_EVENT, INPUT_EVENT } from '../../../utils/constants.mjs';\nimport { on, off } from '../../../utils/dom.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport './button.mjs';\nimport './marker.mjs';\nimport { useMarks } from './useMarks.mjs';\nimport { useSlide } from './useSlide.mjs';\nimport { useStops } from './useStops.mjs';\nimport script$1 from './button.vue_vue&type=script&lang.mjs';\nimport script$2 from './marker.vue_vue&type=script&lang.mjs';\nvar script = defineComponent({\n  name: \"ElSlider\",\n  components: {\n    ElInputNumber: ElInputNumber,\n    SliderButton: script$1,\n    SliderMarker: script$2\n  },\n  props: {\n    modelValue: {\n      type: [Number, Array],\n      \"default\": 0\n    },\n    min: {\n      type: Number,\n      \"default\": 0\n    },\n    max: {\n      type: Number,\n      \"default\": 100\n    },\n    step: {\n      type: Number,\n      \"default\": 1\n    },\n    showInput: {\n      type: Boolean,\n      \"default\": false\n    },\n    showInputControls: {\n      type: Boolean,\n      \"default\": true\n    },\n    inputSize: {\n      type: String,\n      \"default\": \"small\"\n    },\n    showStops: {\n      type: Boolean,\n      \"default\": false\n    },\n    showTooltip: {\n      type: Boolean,\n      \"default\": true\n    },\n    formatTooltip: {\n      type: Function,\n      \"default\": void 0\n    },\n    disabled: {\n      type: Boolean,\n      \"default\": false\n    },\n    range: {\n      type: Boolean,\n      \"default\": false\n    },\n    vertical: {\n      type: Boolean,\n      \"default\": false\n    },\n    height: {\n      type: String,\n      \"default\": \"\"\n    },\n    debounce: {\n      type: Number,\n      \"default\": 300\n    },\n    label: {\n      type: String,\n      \"default\": void 0\n    },\n    tooltipClass: {\n      type: String,\n      \"default\": void 0\n    },\n    marks: Object\n  },\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, INPUT_EVENT],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var initData = reactive({\n      firstValue: 0,\n      secondValue: 0,\n      oldValue: 0,\n      dragging: false,\n      sliderSize: 1\n    });\n\n    var _useSlide = useSlide(props, initData, emit),\n        elFormItem = _useSlide.elFormItem,\n        slider = _useSlide.slider,\n        firstButton = _useSlide.firstButton,\n        secondButton = _useSlide.secondButton,\n        sliderDisabled = _useSlide.sliderDisabled,\n        minValue = _useSlide.minValue,\n        maxValue = _useSlide.maxValue,\n        runwayStyle = _useSlide.runwayStyle,\n        barStyle = _useSlide.barStyle,\n        resetSize = _useSlide.resetSize,\n        emitChange = _useSlide.emitChange,\n        onSliderClick = _useSlide.onSliderClick,\n        setFirstValue = _useSlide.setFirstValue,\n        setSecondValue = _useSlide.setSecondValue;\n\n    var _useStops = useStops(props, initData, minValue, maxValue),\n        stops = _useStops.stops,\n        getStopStyle = _useStops.getStopStyle;\n\n    var markList = useMarks(props);\n    useWatch(props, initData, minValue, maxValue, emit, elFormItem);\n    var precision = computed(function () {\n      var precisions = [props.min, props.max, props.step].map(function (item) {\n        var decimal = \"\".concat(item).split(\".\")[1];\n        return decimal ? decimal.length : 0;\n      });\n      return Math.max.apply(null, precisions);\n    });\n\n    var _useLifecycle = useLifecycle(props, initData, resetSize),\n        sliderWrapper = _useLifecycle.sliderWrapper;\n\n    var _toRefs = toRefs(initData),\n        firstValue = _toRefs.firstValue,\n        secondValue = _toRefs.secondValue,\n        oldValue = _toRefs.oldValue,\n        dragging = _toRefs.dragging,\n        sliderSize = _toRefs.sliderSize;\n\n    var updateDragging = function updateDragging(val) {\n      initData.dragging = val;\n    };\n\n    provide(\"SliderProvider\", _objectSpread(_objectSpread({}, toRefs(props)), {}, {\n      sliderSize: sliderSize,\n      disabled: sliderDisabled,\n      precision: precision,\n      emitChange: emitChange,\n      resetSize: resetSize,\n      updateDragging: updateDragging\n    }));\n    return {\n      firstValue: firstValue,\n      secondValue: secondValue,\n      oldValue: oldValue,\n      dragging: dragging,\n      sliderSize: sliderSize,\n      slider: slider,\n      firstButton: firstButton,\n      secondButton: secondButton,\n      sliderDisabled: sliderDisabled,\n      runwayStyle: runwayStyle,\n      barStyle: barStyle,\n      emitChange: emitChange,\n      onSliderClick: onSliderClick,\n      getStopStyle: getStopStyle,\n      setFirstValue: setFirstValue,\n      setSecondValue: setSecondValue,\n      stops: stops,\n      markList: markList,\n      sliderWrapper: sliderWrapper\n    };\n  }\n});\n\nvar useWatch = function useWatch(props, initData, minValue, maxValue, emit, elFormItem) {\n  var _emit = function _emit(val) {\n    emit(UPDATE_MODEL_EVENT, val);\n    emit(INPUT_EVENT, val);\n  };\n\n  var valueChanged = function valueChanged() {\n    if (props.range) {\n      return ![minValue.value, maxValue.value].every(function (item, index) {\n        return item === initData.oldValue[index];\n      });\n    } else {\n      return props.modelValue !== initData.oldValue;\n    }\n  };\n\n  var setValues = function setValues() {\n    var _a, _b;\n\n    if (props.min > props.max) {\n      throwError(\"Slider\", \"min should not be greater than max.\");\n      return;\n    }\n\n    var val = props.modelValue;\n\n    if (props.range && Array.isArray(val)) {\n      if (val[1] < props.min) {\n        _emit([props.min, props.min]);\n      } else if (val[0] > props.max) {\n        _emit([props.max, props.max]);\n      } else if (val[0] < props.min) {\n        _emit([props.min, val[1]]);\n      } else if (val[1] > props.max) {\n        _emit([val[0], props.max]);\n      } else {\n        initData.firstValue = val[0];\n        initData.secondValue = val[1];\n\n        if (valueChanged()) {\n          (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, \"change\");\n          initData.oldValue = val.slice();\n        }\n      }\n    } else if (!props.range && typeof val === \"number\" && !isNaN(val)) {\n      if (val < props.min) {\n        _emit(props.min);\n      } else if (val > props.max) {\n        _emit(props.max);\n      } else {\n        initData.firstValue = val;\n\n        if (valueChanged()) {\n          (_b = elFormItem.validate) == null ? void 0 : _b.call(elFormItem, \"change\");\n          initData.oldValue = val;\n        }\n      }\n    }\n  };\n\n  setValues();\n  watch(function () {\n    return initData.dragging;\n  }, function (val) {\n    if (!val) {\n      setValues();\n    }\n  });\n  watch(function () {\n    return props.modelValue;\n  }, function (val, oldVal) {\n    if (initData.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every(function (item, index) {\n      return item === oldVal[index];\n    })) {\n      return;\n    }\n\n    setValues();\n  });\n  watch(function () {\n    return [props.min, props.max];\n  }, function () {\n    setValues();\n  });\n};\n\nvar useLifecycle = function useLifecycle(props, initData, resetSize) {\n  var sliderWrapper = ref(null);\n  onMounted( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var valuetext;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (props.range) {\n              if (Array.isArray(props.modelValue)) {\n                initData.firstValue = Math.max(props.min, props.modelValue[0]);\n                initData.secondValue = Math.min(props.max, props.modelValue[1]);\n              } else {\n                initData.firstValue = props.min;\n                initData.secondValue = props.max;\n              }\n\n              initData.oldValue = [initData.firstValue, initData.secondValue];\n              valuetext = \"\".concat(initData.firstValue, \"-\").concat(initData.secondValue);\n            } else {\n              if (typeof props.modelValue !== \"number\" || isNaN(props.modelValue)) {\n                initData.firstValue = props.min;\n              } else {\n                initData.firstValue = Math.min(props.max, Math.max(props.min, props.modelValue));\n              }\n\n              initData.oldValue = initData.firstValue;\n              valuetext = initData.firstValue;\n            }\n\n            sliderWrapper.value.setAttribute(\"aria-valuetext\", valuetext);\n            sliderWrapper.value.setAttribute(\"aria-label\", props.label ? props.label : \"slider between \".concat(props.min, \" and \").concat(props.max));\n            on(window, \"resize\", resetSize);\n            _context.next = 6;\n            return nextTick();\n\n          case 6:\n            resetSize();\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })));\n  onBeforeUnmount(function () {\n    off(window, \"resize\", resetSize);\n  });\n  return {\n    sliderWrapper: sliderWrapper\n  };\n};\n\nexport { script as default };","map":null,"metadata":{},"sourceType":"module"}