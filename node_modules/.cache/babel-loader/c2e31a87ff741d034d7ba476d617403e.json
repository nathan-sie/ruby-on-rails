{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { defineComponent, ref, computed, nextTick, provide, reactive, watch, onBeforeUpdate, onMounted } from 'vue';\nimport isEqual from 'lodash/isEqual';\nimport { EVENT_CODE, focusNode, getSibling } from '../../../utils/aria.mjs';\nimport { UPDATE_MODEL_EVENT, CHANGE_EVENT } from '../../../utils/constants.mjs';\nimport isServer from '../../../utils/isServer.mjs';\nimport scrollIntoView from '../../../utils/scroll-into-view.mjs';\nimport { isEmpty, deduplicate, arrayFlat, coerceTruthyValueToArray } from '../../../utils/util.mjs';\nimport './menu.mjs';\nimport Store from './store.mjs';\nimport Node, { ExpandTrigger } from './node.mjs';\nimport { CommonProps, useCascaderConfig } from './config.mjs';\nimport { sortByOriginalOrder, checkNode, getMenuIndex } from './utils.mjs';\nimport { CASCADER_PANEL_INJECTION_KEY } from './types.mjs';\nimport script$1 from './menu.vue_vue&type=script&lang.mjs';\nvar script = defineComponent({\n  name: \"ElCascaderPanel\",\n  components: {\n    ElCascaderMenu: script$1\n  },\n  props: _objectSpread(_objectSpread({}, CommonProps), {}, {\n    border: {\n      type: Boolean,\n      \"default\": true\n    },\n    renderLabel: Function\n  }),\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, \"close\", \"expand-change\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit,\n        slots = _ref.slots;\n    var initialLoaded = true;\n    var manualChecked = false;\n    var config = useCascaderConfig(props);\n    var store = ref(null);\n    var menuList = ref([]);\n    var checkedValue = ref(null);\n    var menus = ref([]);\n    var expandingNode = ref(null);\n    var checkedNodes = ref([]);\n    var isHoverMenu = computed(function () {\n      return config.value.expandTrigger === ExpandTrigger.HOVER;\n    });\n    var renderLabelFn = computed(function () {\n      return props.renderLabel || slots[\"default\"];\n    });\n\n    var initStore = function initStore() {\n      var options = props.options;\n      var cfg = config.value;\n      manualChecked = false;\n      store.value = new Store(options, cfg);\n      menus.value = [store.value.getNodes()];\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded = false;\n        lazyLoad(void 0, function () {\n          initialLoaded = true;\n          syncCheckedValue(false, true);\n        });\n      } else {\n        syncCheckedValue(false, true);\n      }\n    };\n\n    var lazyLoad = function lazyLoad(node, cb) {\n      var cfg = config.value;\n      node = node || new Node({}, cfg, void 0, true);\n      node.loading = true;\n\n      var resolve = function resolve(dataList) {\n        var _a;\n\n        var _node = node;\n        var parent = _node.root ? null : _node;\n        dataList && ((_a = store.value) == null ? void 0 : _a.appendNodes(dataList, parent));\n        _node.loading = false;\n        _node.loaded = true;\n        _node.childrenData = _node.childrenData || [];\n        cb && cb(dataList);\n      };\n\n      cfg.lazyLoad(node, resolve);\n    };\n\n    var expandNode = function expandNode(node, silent) {\n      var _a;\n\n      var level = node.level;\n      var newMenus = menus.value.slice(0, level);\n      var newExpandingNode;\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2];\n      } else {\n        newExpandingNode = node;\n        newMenus.push(node.children);\n      }\n\n      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {\n        expandingNode.value = node;\n        menus.value = newMenus;\n        !silent && emit(\"expand-change\", (node == null ? void 0 : node.pathValues) || []);\n      }\n    };\n\n    var handleCheckChange = function handleCheckChange(node, checked) {\n      var emitClose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var _config$value = config.value,\n          checkStrictly = _config$value.checkStrictly,\n          multiple = _config$value.multiple;\n      var oldNode = checkedNodes.value[0];\n      manualChecked = true;\n      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));\n      node.doCheck(checked);\n      calculateCheckedValue();\n      emitClose && !multiple && !checkStrictly && emit(\"close\");\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node);\n    };\n\n    var expandParentNode = function expandParentNode(node) {\n      if (!node) return;\n      node = node.parent;\n      expandParentNode(node);\n      node && expandNode(node);\n    };\n\n    var getFlattedNodes = function getFlattedNodes(leafOnly) {\n      var _a;\n\n      return (_a = store.value) == null ? void 0 : _a.getFlattedNodes(leafOnly);\n    };\n\n    var getCheckedNodes = function getCheckedNodes(leafOnly) {\n      var _a;\n\n      return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(function (node) {\n        return node.checked !== false;\n      });\n    };\n\n    var clearCheckedNodes = function clearCheckedNodes() {\n      checkedNodes.value.forEach(function (node) {\n        return node.doCheck(false);\n      });\n      calculateCheckedValue();\n    };\n\n    var calculateCheckedValue = function calculateCheckedValue() {\n      var _a;\n\n      var _config$value2 = config.value,\n          checkStrictly = _config$value2.checkStrictly,\n          multiple = _config$value2.multiple;\n      var oldNodes = checkedNodes.value;\n      var newNodes = getCheckedNodes(!checkStrictly);\n      var nodes = sortByOriginalOrder(oldNodes, newNodes);\n      var values = nodes.map(function (node) {\n        return node.valueByOption;\n      });\n      checkedNodes.value = nodes;\n      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;\n    };\n\n    var syncCheckedValue = function syncCheckedValue() {\n      var loaded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var modelValue = props.modelValue;\n      var _config$value3 = config.value,\n          lazy = _config$value3.lazy,\n          multiple = _config$value3.multiple,\n          checkStrictly = _config$value3.checkStrictly;\n      var leafOnly = !checkStrictly;\n      if (!initialLoaded || manualChecked || !forced && isEqual(modelValue, checkedValue.value)) return;\n\n      if (lazy && !loaded) {\n        var values = deduplicate(arrayFlat(coerceTruthyValueToArray(modelValue)));\n        var nodes = values.map(function (val) {\n          var _a;\n\n          return (_a = store.value) == null ? void 0 : _a.getNodeByValue(val);\n        }).filter(function (node) {\n          return !!node && !node.loaded && !node.loading;\n        });\n\n        if (nodes.length) {\n          nodes.forEach(function (node) {\n            lazyLoad(node, function () {\n              return syncCheckedValue(false, forced);\n            });\n          });\n        } else {\n          syncCheckedValue(true, forced);\n        }\n      } else {\n        var _values = multiple ? coerceTruthyValueToArray(modelValue) : [modelValue];\n\n        var _nodes = deduplicate(_values.map(function (val) {\n          var _a;\n\n          return (_a = store.value) == null ? void 0 : _a.getNodeByValue(val, leafOnly);\n        }));\n\n        syncMenuState(_nodes, false);\n        checkedValue.value = modelValue;\n      }\n    };\n\n    var syncMenuState = function syncMenuState(newCheckedNodes) {\n      var reserveExpandingState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var _a;\n\n      var checkStrictly = config.value.checkStrictly;\n      var oldNodes = checkedNodes.value;\n      var newNodes = newCheckedNodes.filter(function (node) {\n        return !!node && (checkStrictly || node.isLeaf);\n      });\n      var oldExpandingNode = (_a = store.value) == null ? void 0 : _a.getSameNode(expandingNode.value);\n      var newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach(function (node) {\n          return expandNode(node, true);\n        });\n      } else {\n        expandingNode.value = null;\n      }\n\n      oldNodes.forEach(function (node) {\n        return node.doCheck(false);\n      });\n      newNodes.forEach(function (node) {\n        return node.doCheck(true);\n      });\n      checkedNodes.value = newNodes;\n      nextTick(scrollToExpandingNode);\n    };\n\n    var scrollToExpandingNode = function scrollToExpandingNode() {\n      if (isServer) return;\n      menuList.value.forEach(function (menu) {\n        var menuElement = menu == null ? void 0 : menu.$el;\n\n        if (menuElement) {\n          var container = menuElement.querySelector(\".el-scrollbar__wrap\");\n          var activeNode = menuElement.querySelector(\".el-cascader-node.is-active\") || menuElement.querySelector(\".el-cascader-node.in-active-path\");\n          scrollIntoView(container, activeNode);\n        }\n      });\n    };\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var target = e.target;\n      var code = e.code;\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down:\n          {\n            var distance = code === EVENT_CODE.up ? -1 : 1;\n            focusNode(getSibling(target, distance, '.el-cascader-node[tabindex=\"-1\"]'));\n            break;\n          }\n\n        case EVENT_CODE.left:\n          {\n            var preMenu = menuList.value[getMenuIndex(target) - 1];\n            var expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector('.el-cascader-node[aria-expanded=\"true\"]');\n            focusNode(expandedNode);\n            break;\n          }\n\n        case EVENT_CODE.right:\n          {\n            var nextMenu = menuList.value[getMenuIndex(target) + 1];\n            var firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector('.el-cascader-node[tabindex=\"-1\"]');\n            focusNode(firstNode);\n            break;\n          }\n\n        case EVENT_CODE.enter:\n          checkNode(target);\n          break;\n\n        case EVENT_CODE.esc:\n        case EVENT_CODE.tab:\n          emit(\"close\");\n          break;\n      }\n    };\n\n    provide(CASCADER_PANEL_INJECTION_KEY, reactive({\n      config: config,\n      expandingNode: expandingNode,\n      checkedNodes: checkedNodes,\n      isHoverMenu: isHoverMenu,\n      renderLabelFn: renderLabelFn,\n      lazyLoad: lazyLoad,\n      expandNode: expandNode,\n      handleCheckChange: handleCheckChange\n    }));\n    watch([config, function () {\n      return props.options;\n    }], initStore, {\n      deep: true,\n      immediate: true\n    });\n    watch(function () {\n      return props.modelValue;\n    }, function () {\n      manualChecked = false;\n      syncCheckedValue();\n    });\n    watch(checkedValue, function (val) {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val);\n        emit(CHANGE_EVENT, val);\n      }\n    });\n    onBeforeUpdate(function () {\n      return menuList.value = [];\n    });\n    onMounted(function () {\n      return !isEmpty(props.modelValue) && syncCheckedValue();\n    });\n    return {\n      menuList: menuList,\n      menus: menus,\n      checkedNodes: checkedNodes,\n      handleKeyDown: handleKeyDown,\n      handleCheckChange: handleCheckChange,\n      getFlattedNodes: getFlattedNodes,\n      getCheckedNodes: getCheckedNodes,\n      clearCheckedNodes: clearCheckedNodes,\n      calculateCheckedValue: calculateCheckedValue,\n      scrollToExpandingNode: scrollToExpandingNode\n    };\n  }\n});\nexport { script as default };","map":null,"metadata":{},"sourceType":"module"}