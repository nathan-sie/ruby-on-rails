{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { defineComponent, ref, reactive, computed, watch, nextTick, onMounted, onBeforeUnmount, toRefs } from 'vue';\nimport { ElButton } from '../../button/index.mjs';\nimport '../../../directives/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { ElInput } from '../../input/index.mjs';\nimport { ElOverlay } from '../../overlay/index.mjs';\nimport PopupManager from '../../../utils/popup-manager.mjs';\nimport { on, off } from '../../../utils/dom.mjs';\nimport { EVENT_CODE } from '../../../utils/aria.mjs';\nimport { isValidComponentSize } from '../../../utils/validators.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { TypeComponents, TypeComponentsMap } from '../../../utils/icon.mjs';\nimport TrapFocus from '../../../directives/trap-focus/index.mjs';\nimport { useLocaleInject } from '../../../hooks/use-locale/index.mjs';\nimport useModal from '../../../hooks/use-modal/index.mjs';\nimport usePreventGlobal from '../../../hooks/use-prevent-global/index.mjs';\nimport useLockScreen from '../../../hooks/use-lockscreen/index.mjs';\nimport useRestoreActive from '../../../hooks/use-restore-active/index.mjs';\nvar script = defineComponent({\n  name: \"ElMessageBox\",\n  directives: {\n    TrapFocus: TrapFocus\n  },\n  components: _objectSpread({\n    ElButton: ElButton,\n    ElInput: ElInput,\n    ElOverlay: ElOverlay,\n    ElIcon: ElIcon\n  }, TypeComponents),\n  inheritAttrs: false,\n  props: {\n    buttonSize: {\n      type: String,\n      validator: isValidComponentSize\n    },\n    modal: {\n      type: Boolean,\n      \"default\": true\n    },\n    lockScroll: {\n      type: Boolean,\n      \"default\": true\n    },\n    showClose: {\n      type: Boolean,\n      \"default\": true\n    },\n    closeOnClickModal: {\n      type: Boolean,\n      \"default\": true\n    },\n    closeOnPressEscape: {\n      type: Boolean,\n      \"default\": true\n    },\n    closeOnHashChange: {\n      type: Boolean,\n      \"default\": true\n    },\n    center: Boolean,\n    roundButton: {\n      \"default\": false,\n      type: Boolean\n    },\n    container: {\n      type: String,\n      \"default\": \"body\"\n    },\n    boxType: {\n      type: String,\n      \"default\": \"\"\n    }\n  },\n  emits: [\"vanish\", \"action\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n\n    var _useLocaleInject = useLocaleInject(),\n        t = _useLocaleInject.t;\n\n    var visible = ref(false);\n    var state = reactive({\n      beforeClose: null,\n      callback: null,\n      cancelButtonText: \"\",\n      cancelButtonClass: \"\",\n      confirmButtonText: \"\",\n      confirmButtonClass: \"\",\n      customClass: \"\",\n      customStyle: {},\n      dangerouslyUseHTMLString: false,\n      distinguishCancelAndClose: false,\n      icon: \"\",\n      inputPattern: null,\n      inputPlaceholder: \"\",\n      inputType: \"text\",\n      inputValue: null,\n      inputValidator: null,\n      inputErrorMessage: \"\",\n      message: null,\n      modalFade: true,\n      modalClass: \"\",\n      showCancelButton: false,\n      showConfirmButton: true,\n      type: \"\",\n      title: void 0,\n      showInput: false,\n      action: \"\",\n      confirmButtonLoading: false,\n      cancelButtonLoading: false,\n      confirmButtonDisabled: false,\n      editorErrorMessage: \"\",\n      validateError: false,\n      zIndex: PopupManager.nextZIndex()\n    });\n    var typeClass = computed(function () {\n      var type = state.type;\n      return type && TypeComponentsMap[type] ? \"el-message-box-icon--\".concat(type) : \"\";\n    });\n    var iconComponent = computed(function () {\n      return state.icon || TypeComponentsMap[state.type] || \"\";\n    });\n    var hasMessage = computed(function () {\n      return !!state.message;\n    });\n    var inputRef = ref(null);\n    var confirmRef = ref(null);\n    var confirmButtonClasses = computed(function () {\n      return \"el-button--primary \".concat(state.confirmButtonClass);\n    });\n    watch(function () {\n      return state.inputValue;\n    }, /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(val) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return nextTick();\n\n              case 2:\n                if (props.boxType === \"prompt\" && val !== null) {\n                  validate();\n                }\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function (_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }(), {\n      immediate: true\n    });\n    watch(function () {\n      return visible.value;\n    }, function (val) {\n      if (val) {\n        if (props.boxType === \"alert\" || props.boxType === \"confirm\") {\n          nextTick().then(function () {\n            var _a, _b, _c;\n\n            (_c = (_b = (_a = confirmRef.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus) == null ? void 0 : _c.call(_b);\n          });\n        }\n\n        state.zIndex = PopupManager.nextZIndex();\n      }\n\n      if (props.boxType !== \"prompt\") return;\n\n      if (val) {\n        nextTick().then(function () {\n          if (inputRef.value && inputRef.value.$el) {\n            getInputElement().focus();\n          }\n        });\n      } else {\n        state.editorErrorMessage = \"\";\n        state.validateError = false;\n      }\n    });\n    onMounted( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return nextTick();\n\n            case 2:\n              if (props.closeOnHashChange) {\n                on(window, \"hashchange\", doClose);\n              }\n\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    })));\n    onBeforeUnmount(function () {\n      if (props.closeOnHashChange) {\n        off(window, \"hashchange\", doClose);\n      }\n    });\n\n    function doClose() {\n      if (!visible.value) return;\n      visible.value = false;\n      nextTick(function () {\n        if (state.action) emit(\"action\", state.action);\n      });\n    }\n\n    var handleWrapperClick = function handleWrapperClick() {\n      if (props.closeOnClickModal) {\n        handleAction(state.distinguishCancelAndClose ? \"close\" : \"cancel\");\n      }\n    };\n\n    var handleInputEnter = function handleInputEnter() {\n      if (state.inputType !== \"textarea\") {\n        return handleAction(\"confirm\");\n      }\n    };\n\n    var handleAction = function handleAction(action) {\n      var _a;\n\n      if (props.boxType === \"prompt\" && action === \"confirm\" && !validate()) {\n        return;\n      }\n\n      state.action = action;\n\n      if (state.beforeClose) {\n        (_a = state.beforeClose) == null ? void 0 : _a.call(state, action, state, doClose);\n      } else {\n        doClose();\n      }\n    };\n\n    var validate = function validate() {\n      if (props.boxType === \"prompt\") {\n        var inputPattern = state.inputPattern;\n\n        if (inputPattern && !inputPattern.test(state.inputValue || \"\")) {\n          state.editorErrorMessage = state.inputErrorMessage || t(\"el.messagebox.error\");\n          state.validateError = true;\n          return false;\n        }\n\n        var inputValidator = state.inputValidator;\n\n        if (typeof inputValidator === \"function\") {\n          var validateResult = inputValidator(state.inputValue);\n\n          if (validateResult === false) {\n            state.editorErrorMessage = state.inputErrorMessage || t(\"el.messagebox.error\");\n            state.validateError = true;\n            return false;\n          }\n\n          if (typeof validateResult === \"string\") {\n            state.editorErrorMessage = validateResult;\n            state.validateError = true;\n            return false;\n          }\n        }\n      }\n\n      state.editorErrorMessage = \"\";\n      state.validateError = false;\n      return true;\n    };\n\n    var getInputElement = function getInputElement() {\n      var inputRefs = inputRef.value.$refs;\n      return inputRefs.input || inputRefs.textarea;\n    };\n\n    var handleClose = function handleClose() {\n      handleAction(\"close\");\n    };\n\n    if (props.closeOnPressEscape) {\n      useModal({\n        handleClose: handleClose\n      }, visible);\n    } else {\n      usePreventGlobal(visible, \"keydown\", function (e) {\n        return e.code === EVENT_CODE.esc;\n      });\n    }\n\n    if (props.lockScroll) {\n      useLockScreen(visible);\n    }\n\n    useRestoreActive(visible);\n    return _objectSpread(_objectSpread({}, toRefs(state)), {}, {\n      visible: visible,\n      hasMessage: hasMessage,\n      typeClass: typeClass,\n      iconComponent: iconComponent,\n      confirmButtonClasses: confirmButtonClasses,\n      inputRef: inputRef,\n      confirmRef: confirmRef,\n      doClose: doClose,\n      handleClose: handleClose,\n      handleWrapperClick: handleWrapperClick,\n      handleInputEnter: handleInputEnter,\n      handleAction: handleAction,\n      t: t\n    });\n  }\n});\nexport { script as default };","map":null,"metadata":{},"sourceType":"module"}