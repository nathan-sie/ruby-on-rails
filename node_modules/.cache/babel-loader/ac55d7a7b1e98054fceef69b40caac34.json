{"ast":null,"code":"import { ref, shallowRef, watch, computed, nextTick } from 'vue';\nimport { TreeOptionsEnum, NODE_CLICK, CURRENT_CHANGE, NODE_EXPAND, NODE_COLLAPSE } from '../virtual-tree.mjs';\nimport { useCheck } from './useCheck.mjs';\nimport { useFilter } from './useFilter.mjs';\n\nfunction useTree(props, emit) {\n  var expandedKeySet = ref(new Set(props.defaultExpandedKeys));\n  var currentKey = ref();\n  var tree = shallowRef();\n  watch(function () {\n    return props.currentNodeKey;\n  }, function (key) {\n    currentKey.value = key;\n  }, {\n    immediate: true\n  });\n  watch(function () {\n    return props.data;\n  }, function (data) {\n    setData(data);\n  }, {\n    immediate: true\n  });\n\n  var _useCheck = useCheck(props, tree),\n      isIndeterminate = _useCheck.isIndeterminate,\n      isChecked = _useCheck.isChecked,\n      toggleCheckbox = _useCheck.toggleCheckbox,\n      getCheckedKeys = _useCheck.getCheckedKeys,\n      getCheckedNodes = _useCheck.getCheckedNodes,\n      getHalfCheckedKeys = _useCheck.getHalfCheckedKeys,\n      getHalfCheckedNodes = _useCheck.getHalfCheckedNodes,\n      setChecked = _useCheck.setChecked,\n      setCheckedKeys = _useCheck.setCheckedKeys;\n\n  var _useFilter = useFilter(props, tree),\n      doFilter = _useFilter.doFilter,\n      hiddenNodeKeySet = _useFilter.hiddenNodeKeySet,\n      isForceHiddenExpandIcon = _useFilter.isForceHiddenExpandIcon;\n\n  var valueKey = computed(function () {\n    var _a;\n\n    return ((_a = props.props) == null ? void 0 : _a.value) || TreeOptionsEnum.KEY;\n  });\n  var childrenKey = computed(function () {\n    var _a;\n\n    return ((_a = props.props) == null ? void 0 : _a.children) || TreeOptionsEnum.CHILDREN;\n  });\n  var disabledKey = computed(function () {\n    var _a;\n\n    return ((_a = props.props) == null ? void 0 : _a.disabled) || TreeOptionsEnum.DISABLED;\n  });\n  var labelKey = computed(function () {\n    var _a;\n\n    return ((_a = props.props) == null ? void 0 : _a.label) || TreeOptionsEnum.LABEL;\n  });\n  var flattenTree = computed(function () {\n    var expandedKeys = expandedKeySet.value;\n    var hiddenKeys = hiddenNodeKeySet.value;\n    var flattenNodes = [];\n    var nodes = tree.value && tree.value.treeNodes || [];\n\n    function traverse() {\n      var stack = [];\n\n      for (var i = nodes.length - 1; i >= 0; --i) {\n        stack.push(nodes[i]);\n      }\n\n      while (stack.length) {\n        var node = stack.pop();\n        if (!node) continue;\n\n        if (!hiddenKeys.has(node.key)) {\n          flattenNodes.push(node);\n        }\n\n        if (expandedKeys.has(node.key)) {\n          var children = node.children;\n\n          if (children) {\n            var length = children.length;\n\n            for (var _i = length - 1; _i >= 0; --_i) {\n              stack.push(children[_i]);\n            }\n          }\n        }\n      }\n    }\n\n    traverse();\n    return flattenNodes;\n  });\n  var isNotEmpty = computed(function () {\n    return flattenTree.value.length > 0;\n  });\n\n  function createTree(data) {\n    var treeNodeMap = new Map();\n    var levelTreeNodeMap = new Map();\n    var maxLevel = 1;\n\n    function traverse(nodes) {\n      var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : void 0;\n\n      var _a;\n\n      var siblings = [];\n\n      for (var index = 0; index < nodes.length; ++index) {\n        var rawNode = nodes[index];\n        var value = getKey(rawNode);\n        var node = {\n          level: level,\n          key: value,\n          data: rawNode\n        };\n        node.label = getLabel(rawNode);\n        node.parent = parent;\n        var children = getChildren(rawNode);\n        node.disabled = getDisabled(rawNode);\n        node.isLeaf = !children || children.length === 0;\n\n        if (children && children.length) {\n          node.children = traverse(children, level + 1, node);\n        }\n\n        siblings.push(node);\n        treeNodeMap.set(value, node);\n\n        if (!levelTreeNodeMap.has(level)) {\n          levelTreeNodeMap.set(level, []);\n        }\n\n        (_a = levelTreeNodeMap.get(level)) == null ? void 0 : _a.push(node);\n      }\n\n      if (level > maxLevel) {\n        maxLevel = level;\n      }\n\n      return siblings;\n    }\n\n    var treeNodes = traverse(data);\n    return {\n      treeNodeMap: treeNodeMap,\n      levelTreeNodeMap: levelTreeNodeMap,\n      maxLevel: maxLevel,\n      treeNodes: treeNodes\n    };\n  }\n\n  function filter(query) {\n    var keys = doFilter(query);\n\n    if (keys) {\n      expandedKeySet.value = keys;\n    }\n  }\n\n  function getChildren(node) {\n    return node[childrenKey.value];\n  }\n\n  function getKey(node) {\n    if (!node) {\n      return \"\";\n    }\n\n    return node[valueKey.value];\n  }\n\n  function getDisabled(node) {\n    return node[disabledKey.value];\n  }\n\n  function getLabel(node) {\n    return node[labelKey.value];\n  }\n\n  function toggleExpand(node) {\n    var expandedKeys = expandedKeySet.value;\n\n    if (expandedKeys.has(node.key)) {\n      collapse(node);\n    } else {\n      expand(node);\n    }\n  }\n\n  function handleNodeClick(node) {\n    emit(NODE_CLICK, node.data, node);\n    handleCurrentChange(node);\n\n    if (props.expandOnClickNode) {\n      toggleExpand(node);\n    }\n\n    if (props.showCheckbox && props.checkOnClickNode && !node.disabled) {\n      toggleCheckbox(node, !isChecked(node), true);\n    }\n  }\n\n  function handleCurrentChange(node) {\n    if (!isCurrent(node)) {\n      currentKey.value = node.key;\n      emit(CURRENT_CHANGE, node.data, node);\n    }\n  }\n\n  function handleNodeCheck(node, checked) {\n    toggleCheckbox(node, checked);\n  }\n\n  function expand(node) {\n    var keySet = expandedKeySet.value;\n\n    if ((tree == null ? void 0 : tree.value) && props.accordion) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      keySet.forEach(function (key) {\n        var node2 = treeNodeMap.get(key);\n\n        if (node2 && node2.level === node2.level) {\n          keySet[\"delete\"](key);\n        }\n      });\n    }\n\n    keySet.add(node.key);\n    emit(NODE_EXPAND, node.data, node);\n  }\n\n  function collapse(node) {\n    expandedKeySet.value[\"delete\"](node.key);\n    emit(NODE_COLLAPSE, node.data, node);\n  }\n\n  function isExpanded(node) {\n    return expandedKeySet.value.has(node.key);\n  }\n\n  function isDisabled(node) {\n    return !!node.disabled;\n  }\n\n  function isCurrent(node) {\n    var current = currentKey.value;\n    return !!current && current === node.key;\n  }\n\n  function getCurrentNode() {\n    var _a, _b;\n\n    if (!currentKey.value) return void 0;\n    return (_b = (_a = tree == null ? void 0 : tree.value) == null ? void 0 : _a.treeNodeMap.get(currentKey.value)) == null ? void 0 : _b.data;\n  }\n\n  function getCurrentKey() {\n    return currentKey.value;\n  }\n\n  function setCurrentKey(key) {\n    currentKey.value = key;\n  }\n\n  function setData(data) {\n    nextTick(function () {\n      return tree.value = createTree(data);\n    });\n  }\n\n  return {\n    tree: tree,\n    flattenTree: flattenTree,\n    isNotEmpty: isNotEmpty,\n    getKey: getKey,\n    getChildren: getChildren,\n    toggleExpand: toggleExpand,\n    toggleCheckbox: toggleCheckbox,\n    isExpanded: isExpanded,\n    isChecked: isChecked,\n    isIndeterminate: isIndeterminate,\n    isDisabled: isDisabled,\n    isCurrent: isCurrent,\n    isForceHiddenExpandIcon: isForceHiddenExpandIcon,\n    handleNodeClick: handleNodeClick,\n    handleNodeCheck: handleNodeCheck,\n    getCurrentNode: getCurrentNode,\n    getCurrentKey: getCurrentKey,\n    setCurrentKey: setCurrentKey,\n    getCheckedKeys: getCheckedKeys,\n    getCheckedNodes: getCheckedNodes,\n    getHalfCheckedKeys: getHalfCheckedKeys,\n    getHalfCheckedNodes: getHalfCheckedNodes,\n    setChecked: setChecked,\n    setCheckedKeys: setCheckedKeys,\n    filter: filter,\n    setData: setData\n  };\n}\n\nexport { useTree };","map":null,"metadata":{},"sourceType":"module"}