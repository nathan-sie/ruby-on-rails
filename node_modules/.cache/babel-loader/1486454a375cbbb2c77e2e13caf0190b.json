{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport isServer from './isServer.mjs';\nimport './util.mjs';\nimport { camelize, isObject } from '@vue/shared';\n\nvar trimArr = function trimArr(s) {\n  return (s || \"\").split(\" \").filter(function (item) {\n    return !!item.trim();\n  });\n};\n\nvar on = function on(element, event, handler) {\n  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (element && event && handler) {\n    element == null ? void 0 : element.addEventListener(event, handler, useCapture);\n  }\n};\n\nvar off = function off(element, event, handler) {\n  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (element && event && handler) {\n    element == null ? void 0 : element.removeEventListener(event, handler, useCapture);\n  }\n};\n\nvar once = function once(el, event, fn) {\n  var listener = function listener() {\n    if (fn) {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      fn.apply(this, args);\n    }\n\n    off(el, event, listener);\n  };\n\n  on(el, event, listener);\n};\n\nfunction hasClass(el, cls) {\n  if (!el || !cls) return false;\n  if (cls.indexOf(\" \") !== -1) throw new Error(\"className should not contain space.\");\n\n  if (el.classList) {\n    return el.classList.contains(cls);\n  } else {\n    var className = el.getAttribute(\"class\") || \"\";\n    return className.split(\" \").includes(cls);\n  }\n}\n\nfunction addClass(el, cls) {\n  if (!el) return;\n  var className = el.getAttribute(\"class\") || \"\";\n  var curClass = trimArr(className);\n  var classes = (cls || \"\").split(\" \").filter(function (item) {\n    return !curClass.includes(item) && !!item.trim();\n  });\n\n  if (el.classList) {\n    var _el$classList;\n\n    (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(classes));\n  } else {\n    className += \" \".concat(classes.join(\" \"));\n    el.setAttribute(\"class\", className);\n  }\n}\n\nfunction removeClass(el, cls) {\n  if (!el || !cls) return;\n  var classes = trimArr(cls);\n  var curClass = el.getAttribute(\"class\") || \"\";\n\n  if (el.classList) {\n    var _el$classList2;\n\n    (_el$classList2 = el.classList).remove.apply(_el$classList2, _toConsumableArray(classes));\n\n    return;\n  }\n\n  classes.forEach(function (item) {\n    curClass = curClass.replace(\" \".concat(item, \" \"), \" \");\n  });\n  var className = trimArr(curClass).join(\" \");\n  el.setAttribute(\"class\", className);\n}\n\nvar getStyle = function getStyle(element, styleName) {\n  var _a;\n\n  if (isServer) return \"\";\n  if (!element || !styleName) return \"\";\n  styleName = camelize(styleName);\n\n  if (styleName === \"float\") {\n    styleName = \"cssFloat\";\n  }\n\n  try {\n    var style = element.style[styleName];\n    if (style) return style;\n    var computed = (_a = document.defaultView) == null ? void 0 : _a.getComputedStyle(element, \"\");\n    return computed ? computed[styleName] : \"\";\n  } catch (e) {\n    return element.style[styleName];\n  }\n};\n\nfunction setStyle(element, styleName, value) {\n  if (!element || !styleName) return;\n\n  if (isObject(styleName)) {\n    Object.keys(styleName).forEach(function (prop) {\n      setStyle(element, prop, styleName[prop]);\n    });\n  } else {\n    styleName = camelize(styleName);\n    element.style[styleName] = value;\n  }\n}\n\nfunction removeStyle(element, style) {\n  if (!element || !style) return;\n\n  if (isObject(style)) {\n    Object.keys(style).forEach(function (prop) {\n      setStyle(element, prop, \"\");\n    });\n  } else {\n    setStyle(element, style, \"\");\n  }\n}\n\nvar isScroll = function isScroll(el, isVertical) {\n  if (isServer) return null;\n  var determinedDirection = isVertical === null || isVertical === void 0;\n  var overflow = determinedDirection ? getStyle(el, \"overflow\") : isVertical ? getStyle(el, \"overflow-y\") : getStyle(el, \"overflow-x\");\n  return overflow.match(/(scroll|auto|overlay)/);\n};\n\nvar getScrollContainer = function getScrollContainer(el, isVertical) {\n  if (isServer) return;\n  var parent = el;\n\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent)) {\n      return window;\n    }\n\n    if (isScroll(parent, isVertical)) {\n      return parent;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return parent;\n};\n\nvar isInContainer = function isInContainer(el, container) {\n  if (isServer || !el || !container) return false;\n  var elRect = el.getBoundingClientRect();\n  var containerRect;\n\n  if (container instanceof Element) {\n    containerRect = container.getBoundingClientRect();\n  } else {\n    containerRect = {\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      left: 0\n    };\n  }\n\n  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;\n};\n\nvar getOffsetTop = function getOffsetTop(el) {\n  var offset = 0;\n  var parent = el;\n\n  while (parent) {\n    offset += parent.offsetTop;\n    parent = parent.offsetParent;\n  }\n\n  return offset;\n};\n\nvar getOffsetTopDistance = function getOffsetTopDistance(el, containerEl) {\n  return Math.abs(getOffsetTop(el) - getOffsetTop(containerEl));\n};\n\nvar stop = function stop(e) {\n  return e.stopPropagation();\n};\n\nexport { addClass, getOffsetTop, getOffsetTopDistance, getScrollContainer, getStyle, hasClass, isInContainer, isScroll, off, on, once, removeClass, removeStyle, setStyle, stop };","map":null,"metadata":{},"sourceType":"module"}