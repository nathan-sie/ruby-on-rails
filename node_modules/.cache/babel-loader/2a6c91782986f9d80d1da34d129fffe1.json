{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { defineComponent, inject, ref, computed, onUpdated, onMounted, onBeforeUnmount, h } from 'vue';\nimport { NOOP, capitalize } from '@vue/shared';\nimport { EVENT_CODE } from '../../../utils/aria.mjs';\nimport { addResizeListener, removeResizeListener } from '../../../utils/resize-event.mjs';\nimport { on, off } from '../../../utils/dom.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons';\nimport './tab-bar.mjs';\nimport script$1 from './tab-bar.vue_vue&type=script&lang.mjs';\nvar script = defineComponent({\n  name: \"ElTabNav\",\n  components: {\n    TabBar: script$1\n  },\n  props: {\n    panes: {\n      type: Array,\n      \"default\": function _default() {\n        return [];\n      }\n    },\n    currentName: {\n      type: String,\n      \"default\": \"\"\n    },\n    editable: Boolean,\n    onTabClick: {\n      type: Function,\n      \"default\": NOOP\n    },\n    onTabRemove: {\n      type: Function,\n      \"default\": NOOP\n    },\n    type: {\n      type: String,\n      \"default\": \"\"\n    },\n    stretch: Boolean\n  },\n  setup: function setup() {\n    var rootTabs = inject(\"rootTabs\");\n\n    if (!rootTabs) {\n      throwError(\"[ElTabNav]\", \"ElTabNav must be nested inside ElTabs\");\n    }\n\n    var scrollable = ref(false);\n    var navOffset = ref(0);\n    var isFocus = ref(false);\n    var focusable = ref(true);\n    var navScroll$ = ref(null);\n    var nav$ = ref(null);\n    var el$ = ref(null);\n    var sizeName = computed(function () {\n      return [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\";\n    });\n    var navStyle = computed(function () {\n      var dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: \"translate\".concat(dir, \"(-\").concat(navOffset.value, \"px)\")\n      };\n    });\n\n    var scrollPrev = function scrollPrev() {\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      var newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n\n    var scrollNext = function scrollNext() {\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      var newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n\n    var scrollToActiveTab = function scrollToActiveTab() {\n      if (!scrollable.value) return;\n      var nav = nav$.value;\n      var activeTab = el$.value.querySelector(\".is-active\");\n      if (!activeTab) return;\n      var navScroll = navScroll$.value;\n      var isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n      var activeTabBounding = activeTab.getBoundingClientRect();\n      var navScrollBounding = navScroll.getBoundingClientRect();\n      var maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n      var currentOffset = navOffset.value;\n      var newOffset = currentOffset;\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n        }\n\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n        }\n\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n        }\n      }\n\n      newOffset = Math.max(newOffset, 0);\n      navOffset.value = Math.min(newOffset, maxOffset);\n    };\n\n    var update = function update() {\n      if (!nav$.value) return;\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n\n      if (containerSize < navSize) {\n        var currentOffset2 = navOffset.value;\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset2;\n        scrollable.value.next = currentOffset2 + containerSize < navSize;\n\n        if (navSize - currentOffset2 < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n\n    var changeTab = function changeTab(e) {\n      var code = e.code;\n      var nextIndex;\n      var currentIndex, tabList;\n      var up = EVENT_CODE.up,\n          down = EVENT_CODE.down,\n          left = EVENT_CODE.left,\n          right = EVENT_CODE.right;\n\n      if ([up, down, left, right].indexOf(code) !== -1) {\n        tabList = e.currentTarget.querySelectorAll(\"[role=tab]\");\n        currentIndex = Array.prototype.indexOf.call(tabList, e.target);\n      } else {\n        return;\n      }\n\n      if (code === left || code === up) {\n        if (currentIndex === 0) {\n          nextIndex = tabList.length - 1;\n        } else {\n          nextIndex = currentIndex - 1;\n        }\n      } else {\n        if (currentIndex < tabList.length - 1) {\n          nextIndex = currentIndex + 1;\n        } else {\n          nextIndex = 0;\n        }\n      }\n\n      tabList[nextIndex].focus();\n      tabList[nextIndex].click();\n      setFocus();\n    };\n\n    var setFocus = function setFocus() {\n      if (focusable.value) {\n        isFocus.value = true;\n      }\n    };\n\n    var removeFocus = function removeFocus() {\n      isFocus.value = false;\n    };\n\n    var visibilityChangeHandler = function visibilityChangeHandler() {\n      var visibility = document.visibilityState;\n\n      if (visibility === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility === \"visible\") {\n        setTimeout(function () {\n          focusable.value = true;\n        }, 50);\n      }\n    };\n\n    var windowBlurHandler = function windowBlurHandler() {\n      focusable.value = false;\n    };\n\n    var windowFocusHandler = function windowFocusHandler() {\n      setTimeout(function () {\n        focusable.value = true;\n      }, 50);\n    };\n\n    onUpdated(function () {\n      update();\n    });\n    onMounted(function () {\n      addResizeListener(el$.value, update);\n      on(document, \"visibilitychange\", visibilityChangeHandler);\n      on(window, \"blur\", windowBlurHandler);\n      on(window, \"focus\", windowFocusHandler);\n      setTimeout(function () {\n        scrollToActiveTab();\n      }, 0);\n    });\n    onBeforeUnmount(function () {\n      if (el$.value) {\n        removeResizeListener(el$.value, update);\n      }\n\n      off(document, \"visibilitychange\", visibilityChangeHandler);\n      off(window, \"blur\", windowBlurHandler);\n      off(window, \"focus\", windowFocusHandler);\n    });\n    return {\n      rootTabs: rootTabs,\n      scrollable: scrollable,\n      navOffset: navOffset,\n      isFocus: isFocus,\n      focusable: focusable,\n      navScroll$: navScroll$,\n      nav$: nav$,\n      el$: el$,\n      sizeName: sizeName,\n      navStyle: navStyle,\n      scrollPrev: scrollPrev,\n      scrollNext: scrollNext,\n      scrollToActiveTab: scrollToActiveTab,\n      update: update,\n      changeTab: changeTab,\n      setFocus: setFocus,\n      removeFocus: removeFocus,\n      visibilityChangeHandler: visibilityChangeHandler,\n      windowBlurHandler: windowBlurHandler,\n      windowFocusHandler: windowFocusHandler\n    };\n  },\n  render: function render() {\n    var type = this.type,\n        panes = this.panes,\n        editable = this.editable,\n        stretch = this.stretch,\n        onTabClick = this.onTabClick,\n        onTabRemove = this.onTabRemove,\n        navStyle = this.navStyle,\n        scrollable = this.scrollable,\n        scrollNext = this.scrollNext,\n        scrollPrev = this.scrollPrev,\n        changeTab = this.changeTab,\n        setFocus = this.setFocus,\n        removeFocus = this.removeFocus,\n        rootTabs = this.rootTabs,\n        isFocus = this.isFocus;\n    var scrollBtn = scrollable ? [h(\"span\", {\n      \"class\": [\"el-tabs__nav-prev\", scrollable.prev ? \"\" : \"is-disabled\"],\n      onClick: scrollPrev\n    }, [h(ElIcon, {}, {\n      \"default\": function _default() {\n        return h(ArrowLeft);\n      }\n    })]), h(\"span\", {\n      \"class\": [\"el-tabs__nav-next\", scrollable.next ? \"\" : \"is-disabled\"],\n      onClick: scrollNext\n    }, [h(ElIcon, {}, {\n      \"default\": function _default() {\n        return h(ArrowRight);\n      }\n    })])] : null;\n    var tabs = panes.map(function (pane, index) {\n      var _class;\n\n      var _a, _b;\n\n      var tabName = pane.props.name || pane.index || \"\".concat(index);\n      var closable = pane.isClosable || editable;\n      pane.index = \"\".concat(index);\n      var btnClose = closable ? h(ElIcon, {\n        \"class\": \"is-icon-close\",\n        onClick: function onClick(ev) {\n          onTabRemove(pane, ev);\n        }\n      }, {\n        \"default\": function _default() {\n          return h(Close);\n        }\n      }) : null;\n      var tabLabelContent = ((_b = (_a = pane.instance.slots).label) == null ? void 0 : _b.call(_a)) || pane.props.label;\n      var tabindex = pane.active ? 0 : -1;\n      return h(\"div\", {\n        \"class\": (_class = {\n          \"el-tabs__item\": true\n        }, _defineProperty(_class, \"is-\".concat(rootTabs.props.tabPosition), true), _defineProperty(_class, \"is-active\", pane.active), _defineProperty(_class, \"is-disabled\", pane.props.disabled), _defineProperty(_class, \"is-closable\", closable), _defineProperty(_class, \"is-focus\", isFocus), _class),\n        id: \"tab-\".concat(tabName),\n        key: \"tab-\".concat(tabName),\n        \"aria-controls\": \"pane-\".concat(tabName),\n        role: \"tab\",\n        \"aria-selected\": pane.active,\n        ref: \"tab-\".concat(tabName),\n        tabindex: tabindex,\n        onFocus: function onFocus() {\n          setFocus();\n        },\n        onBlur: function onBlur() {\n          removeFocus();\n        },\n        onClick: function onClick(ev) {\n          removeFocus();\n          onTabClick(pane, tabName, ev);\n        },\n        onKeydown: function onKeydown(ev) {\n          if (closable && (ev.code === EVENT_CODE[\"delete\"] || ev.code === EVENT_CODE.backspace)) {\n            onTabRemove(pane, ev);\n          }\n        }\n      }, [tabLabelContent, btnClose]);\n    });\n    return h(\"div\", {\n      ref: \"el$\",\n      \"class\": [\"el-tabs__nav-wrap\", scrollable ? \"is-scrollable\" : \"\", \"is-\".concat(rootTabs.props.tabPosition)]\n    }, [scrollBtn, h(\"div\", {\n      \"class\": \"el-tabs__nav-scroll\",\n      ref: \"navScroll$\"\n    }, [h(\"div\", {\n      \"class\": [\"el-tabs__nav\", \"is-\".concat(rootTabs.props.tabPosition), stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"is-stretch\" : \"\"],\n      ref: \"nav$\",\n      style: navStyle,\n      role: \"tablist\",\n      onKeydown: changeTab\n    }, [!type ? h(script$1, {\n      tabs: _toConsumableArray(panes)\n    }) : null, tabs])])]);\n  }\n});\nexport { script as default };","map":null,"metadata":{},"sourceType":"module"}