{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, h, resolveDynamicComponent } from 'vue';\nimport { hasOwn, isString } from '@vue/shared';\nimport { isNumber } from '../../../../utils/util.mjs';\nimport isServer from '../../../../utils/isServer.mjs';\nimport scrollbarWidth from '../../../../utils/scrollbar-width.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { useGridWheel } from '../hooks/use-grid-wheel.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport { virtualizedGridProps } from '../props.mjs';\nimport { isRTL, getRTLOffsetType, getScrollDir } from '../utils.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, FORWARD, BACKWARD, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, RTL, RTL_OFFSET_POS_ASC } from '../defaults.mjs';\n\nvar createGrid = function createGrid(_ref) {\n  var name = _ref.name,\n      clearCache = _ref.clearCache,\n      getColumnPosition = _ref.getColumnPosition,\n      getColumnStartIndexForOffset = _ref.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref.getColumnStopIndexForStartIndex,\n      getEstimatedTotalHeight = _ref.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref.getEstimatedTotalWidth,\n      getColumnOffset = _ref.getColumnOffset,\n      getRowOffset = _ref.getRowOffset,\n      getRowPosition = _ref.getRowPosition,\n      getRowStartIndexForOffset = _ref.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref.getRowStopIndexForStartIndex,\n      initCache = _ref.initCache,\n      validateProps = _ref.validateProps;\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedGridProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup: function setup(props, _ref2) {\n      var emit = _ref2.emit,\n          expose = _ref2.expose,\n          slots = _ref2.slots;\n      validateProps(props);\n      var instance = getCurrentInstance();\n      var cache = ref(initCache(props, instance));\n      var windowRef = ref();\n      var hScrollbar = ref();\n      var vScrollbar = ref();\n      var innerRef = ref(null);\n      var states = ref({\n        isScrolling: false,\n        scrollLeft: isNumber(props.initScrollLeft) ? props.initScrollLeft : 0,\n        scrollTop: isNumber(props.initScrollTop) ? props.initScrollTop : 0,\n        updateRequested: false,\n        xAxisScrollDir: FORWARD,\n        yAxisScrollDir: FORWARD\n      });\n      var getItemStyleCache = useCache();\n      var parsedHeight = computed(function () {\n        return parseInt(\"\".concat(props.height), 10);\n      });\n      var parsedWidth = computed(function () {\n        return parseInt(\"\".concat(props.width), 10);\n      });\n      var columnsToRender = computed(function () {\n        var totalColumn = props.totalColumn,\n            totalRow = props.totalRow,\n            columnCache = props.columnCache;\n\n        var _unref = unref(states),\n            isScrolling = _unref.isScrolling,\n            xAxisScrollDir = _unref.xAxisScrollDir,\n            scrollLeft = _unref.scrollLeft;\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        var startIndex = getColumnStartIndexForOffset(props, scrollLeft, unref(cache));\n        var stopIndex = getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, unref(cache));\n        var cacheBackward = !isScrolling || xAxisScrollDir === BACKWARD ? Math.max(1, columnCache) : 1;\n        var cacheForward = !isScrolling || xAxisScrollDir === FORWARD ? Math.max(1, columnCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalColumn - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var rowsToRender = computed(function () {\n        var totalColumn = props.totalColumn,\n            totalRow = props.totalRow,\n            rowCache = props.rowCache;\n\n        var _unref2 = unref(states),\n            isScrolling = _unref2.isScrolling,\n            yAxisScrollDir = _unref2.yAxisScrollDir,\n            scrollTop = _unref2.scrollTop;\n\n        if (totalColumn === 0 || totalRow === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        var startIndex = getRowStartIndexForOffset(props, scrollTop, unref(cache));\n        var stopIndex = getRowStopIndexForStartIndex(props, startIndex, scrollTop, unref(cache));\n        var cacheBackward = !isScrolling || yAxisScrollDir === BACKWARD ? Math.max(1, rowCache) : 1;\n        var cacheForward = !isScrolling || yAxisScrollDir === FORWARD ? Math.max(1, rowCache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(totalRow - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var estimatedTotalHeight = computed(function () {\n        return getEstimatedTotalHeight(props, unref(cache));\n      });\n      var estimatedTotalWidth = computed(function () {\n        return getEstimatedTotalWidth(props, unref(cache));\n      });\n      var windowStyle = computed(function () {\n        var _a;\n\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? \"\".concat(props.height, \"px\") : props.height,\n          width: isNumber(props.width) ? \"\".concat(props.width, \"px\") : props.width\n        }, (_a = props.style) != null ? _a : {}];\n      });\n      var innerStyle = computed(function () {\n        var width = \"\".concat(unref(estimatedTotalWidth), \"px\");\n        var height = \"\".concat(unref(estimatedTotalHeight), \"px\");\n        return {\n          height: height,\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: width\n        };\n      });\n\n      var emitEvents = function emitEvents() {\n        var totalColumn = props.totalColumn,\n            totalRow = props.totalRow;\n\n        if (totalColumn > 0 && totalRow > 0) {\n          var _unref3 = unref(columnsToRender),\n              _unref4 = _slicedToArray(_unref3, 4),\n              columnCacheStart = _unref4[0],\n              columnCacheEnd = _unref4[1],\n              columnVisibleStart = _unref4[2],\n              columnVisibleEnd = _unref4[3];\n\n          var _unref5 = unref(rowsToRender),\n              _unref6 = _slicedToArray(_unref5, 4),\n              rowCacheStart = _unref6[0],\n              rowCacheEnd = _unref6[1],\n              rowVisibleStart = _unref6[2],\n              rowVisibleEnd = _unref6[3];\n\n          emit(ITEM_RENDER_EVT, columnCacheStart, columnCacheEnd, rowCacheStart, rowCacheEnd, columnVisibleStart, columnVisibleEnd, rowVisibleStart, rowVisibleEnd);\n        }\n\n        var _unref7 = unref(states),\n            scrollLeft = _unref7.scrollLeft,\n            scrollTop = _unref7.scrollTop,\n            updateRequested = _unref7.updateRequested,\n            xAxisScrollDir = _unref7.xAxisScrollDir,\n            yAxisScrollDir = _unref7.yAxisScrollDir;\n\n        emit(SCROLL_EVT, xAxisScrollDir, scrollLeft, yAxisScrollDir, scrollTop, updateRequested);\n      };\n\n      var onScroll = function onScroll(e) {\n        var _e$currentTarget = e.currentTarget,\n            clientHeight = _e$currentTarget.clientHeight,\n            clientWidth = _e$currentTarget.clientWidth,\n            scrollHeight = _e$currentTarget.scrollHeight,\n            scrollLeft = _e$currentTarget.scrollLeft,\n            scrollTop = _e$currentTarget.scrollTop,\n            scrollWidth = _e$currentTarget.scrollWidth;\n\n        var _states = unref(states);\n\n        if (_states.scrollTop === scrollTop && _states.scrollLeft === scrollLeft) {\n          return;\n        }\n\n        var _scrollLeft = scrollLeft;\n\n        if (isRTL(props.direction)) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              _scrollLeft = -scrollLeft;\n              break;\n\n            case RTL_OFFSET_POS_DESC:\n              _scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        }\n\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollLeft: _scrollLeft,\n          scrollTop: Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight)),\n          updateRequested: false,\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, _scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop)\n        });\n        nextTick(resetIsScrolling);\n        emitEvents();\n      };\n\n      var onVerticalScroll = function onVerticalScroll(distance, totalSteps) {\n        var height = unref(parsedHeight);\n        var offset = (estimatedTotalHeight.value - height) / totalSteps * distance;\n        scrollTo({\n          scrollTop: Math.min(estimatedTotalHeight.value - height, offset)\n        });\n      };\n\n      var onHorizontalScroll = function onHorizontalScroll(distance, totalSteps) {\n        var width = unref(parsedWidth);\n        var offset = (estimatedTotalWidth.value - width) / totalSteps * distance;\n        scrollTo({\n          scrollLeft: Math.min(estimatedTotalWidth.value - width, offset)\n        });\n      };\n\n      var _useGridWheel = useGridWheel({\n        atXStartEdge: computed(function () {\n          return states.value.scrollLeft <= 0;\n        }),\n        atXEndEdge: computed(function () {\n          return states.value.scrollLeft >= estimatedTotalWidth.value;\n        }),\n        atYStartEdge: computed(function () {\n          return states.value.scrollTop <= 0;\n        }),\n        atYEndEdge: computed(function () {\n          return states.value.scrollTop >= estimatedTotalHeight.value;\n        })\n      }, function (x, y) {\n        var _a, _b, _c, _d;\n\n        (_b = (_a = hScrollbar.value) == null ? void 0 : _a.onMouseUp) == null ? void 0 : _b.call(_a);\n        (_d = (_c = hScrollbar.value) == null ? void 0 : _c.onMouseUp) == null ? void 0 : _d.call(_c);\n        var width = unref(parsedWidth);\n        var height = unref(parsedHeight);\n        scrollTo({\n          scrollLeft: Math.min(states.value.scrollLeft + x, estimatedTotalWidth.value - width),\n          scrollTop: Math.min(states.value.scrollTop + y, estimatedTotalHeight.value - height)\n        });\n      }),\n          onWheel = _useGridWheel.onWheel;\n\n      var scrollTo = function scrollTo(_ref3) {\n        var _ref3$scrollLeft = _ref3.scrollLeft,\n            scrollLeft = _ref3$scrollLeft === void 0 ? states.value.scrollLeft : _ref3$scrollLeft,\n            _ref3$scrollTop = _ref3.scrollTop,\n            scrollTop = _ref3$scrollTop === void 0 ? states.value.scrollTop : _ref3$scrollTop;\n        scrollLeft = Math.max(scrollLeft, 0);\n        scrollTop = Math.max(scrollTop, 0);\n\n        var _states = unref(states);\n\n        if (scrollTop === _states.scrollTop && scrollLeft === _states.scrollLeft) {\n          return;\n        }\n\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          xAxisScrollDir: getScrollDir(_states.scrollLeft, scrollLeft),\n          yAxisScrollDir: getScrollDir(_states.scrollTop, scrollTop),\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      var scrollToItem = function scrollToItem() {\n        var rowIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var columnIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var alignment = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AUTO_ALIGNMENT;\n\n        var _states = unref(states);\n\n        columnIdx = Math.max(0, Math.min(columnIdx, props.totalColumn - 1));\n        rowIndex = Math.max(0, Math.min(rowIndex, props.totalRow - 1));\n        var scrollBarWidth = scrollbarWidth();\n\n        var _cache = unref(cache);\n\n        var estimatedHeight = getEstimatedTotalHeight(props, _cache);\n        var estimatedWidth = getEstimatedTotalWidth(props, _cache);\n        scrollTo({\n          scrollLeft: getColumnOffset(props, columnIdx, alignment, _states.scrollLeft, _cache, estimatedWidth > props.width ? scrollBarWidth : 0),\n          scrollTop: getRowOffset(props, rowIndex, alignment, _states.scrollTop, _cache, estimatedHeight > props.height ? scrollBarWidth : 0)\n        });\n      };\n\n      var getItemStyle = function getItemStyle(rowIndex, columnIndex) {\n        var columnWidth = props.columnWidth,\n            direction = props.direction,\n            rowHeight = props.rowHeight;\n        var itemStyleCache = getItemStyleCache.value(clearCache && columnWidth, clearCache && rowHeight, clearCache && direction);\n        var key = \"\".concat(rowIndex, \",\").concat(columnIndex);\n\n        if (hasOwn(itemStyleCache, key)) {\n          return itemStyleCache[key];\n        } else {\n          var _getColumnPosition = getColumnPosition(props, columnIndex, unref(cache)),\n              _getColumnPosition2 = _slicedToArray(_getColumnPosition, 2),\n              left = _getColumnPosition2[1];\n\n          var _cache = unref(cache);\n\n          var rtl = isRTL(direction);\n\n          var _getRowPosition = getRowPosition(props, rowIndex, _cache),\n              _getRowPosition2 = _slicedToArray(_getRowPosition, 2),\n              height = _getRowPosition2[0],\n              top = _getRowPosition2[1];\n\n          var _getColumnPosition3 = getColumnPosition(props, columnIndex, _cache),\n              _getColumnPosition4 = _slicedToArray(_getColumnPosition3, 1),\n              width = _getColumnPosition4[0];\n\n          itemStyleCache[key] = {\n            position: \"absolute\",\n            left: rtl ? void 0 : \"\".concat(left, \"px\"),\n            right: rtl ? \"\".concat(left, \"px\") : void 0,\n            top: \"\".concat(top, \"px\"),\n            height: \"\".concat(height, \"px\"),\n            width: \"\".concat(width, \"px\")\n          };\n          return itemStyleCache[key];\n        }\n      };\n\n      var resetIsScrolling = function resetIsScrolling() {\n        states.value.isScrolling = false;\n        nextTick(function () {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      onMounted(function () {\n        if (isServer) return;\n        var initScrollLeft = props.initScrollLeft,\n            initScrollTop = props.initScrollTop;\n        var windowElement = unref(windowRef);\n\n        if (windowElement) {\n          if (isNumber(initScrollLeft)) {\n            windowElement.scrollLeft = initScrollLeft;\n          }\n\n          if (isNumber(initScrollTop)) {\n            windowElement.scrollTop = initScrollTop;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(function () {\n        var direction = props.direction;\n\n        var _unref8 = unref(states),\n            scrollLeft = _unref8.scrollLeft,\n            scrollTop = _unref8.scrollTop,\n            updateRequested = _unref8.updateRequested;\n\n        var windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (direction === RTL) {\n            switch (getRTLOffsetType()) {\n              case RTL_OFFSET_NAG:\n                {\n                  windowElement.scrollLeft = -scrollLeft;\n                  break;\n                }\n\n              case RTL_OFFSET_POS_ASC:\n                {\n                  windowElement.scrollLeft = scrollLeft;\n                  break;\n                }\n\n              default:\n                {\n                  var clientWidth = windowElement.clientWidth,\n                      scrollWidth = windowElement.scrollWidth;\n                  windowElement.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n                  break;\n                }\n            }\n          } else {\n            windowElement.scrollLeft = Math.max(0, scrollLeft);\n          }\n\n          windowElement.scrollTop = Math.max(0, scrollTop);\n        }\n      });\n      expose({\n        windowRef: windowRef,\n        innerRef: innerRef,\n        getItemStyleCache: getItemStyleCache,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        states: states\n      });\n\n      var renderScrollbars = function renderScrollbars() {\n        var totalColumn = props.totalColumn,\n            totalRow = props.totalRow;\n        var width = unref(parsedWidth);\n        var height = unref(parsedHeight);\n        var estimatedWidth = unref(estimatedTotalWidth);\n        var estimatedHeight = unref(estimatedTotalHeight);\n\n        var _unref9 = unref(states),\n            scrollLeft = _unref9.scrollLeft,\n            scrollTop = _unref9.scrollTop;\n\n        var horizontalScrollbar = h(ScrollBar, {\n          ref: hScrollbar,\n          clientSize: width,\n          layout: \"horizontal\",\n          onScroll: onHorizontalScroll,\n          ratio: width * 100 / estimatedWidth,\n          scrollFrom: scrollLeft / (estimatedWidth - width),\n          total: totalRow,\n          visible: true\n        });\n        var verticalScrollbar = h(ScrollBar, {\n          ref: vScrollbar,\n          clientSize: height,\n          layout: \"vertical\",\n          onScroll: onVerticalScroll,\n          ratio: height * 100 / estimatedHeight,\n          scrollFrom: scrollTop / (estimatedHeight - height),\n          total: totalColumn,\n          visible: true\n        });\n        return {\n          horizontalScrollbar: horizontalScrollbar,\n          verticalScrollbar: verticalScrollbar\n        };\n      };\n\n      var renderItems = function renderItems() {\n        var _a;\n\n        var _unref10 = unref(columnsToRender),\n            _unref11 = _slicedToArray(_unref10, 2),\n            columnStart = _unref11[0],\n            columnEnd = _unref11[1];\n\n        var _unref12 = unref(rowsToRender),\n            _unref13 = _slicedToArray(_unref12, 2),\n            rowStart = _unref13[0],\n            rowEnd = _unref13[1];\n\n        var data = props.data,\n            totalColumn = props.totalColumn,\n            totalRow = props.totalRow,\n            useIsScrolling = props.useIsScrolling;\n        var children = [];\n\n        if (totalRow > 0 && totalColumn > 0) {\n          for (var row = rowStart; row <= rowEnd; row++) {\n            for (var column = columnStart; column <= columnEnd; column++) {\n              children.push((_a = slots[\"default\"]) == null ? void 0 : _a.call(slots, {\n                columnIndex: column,\n                data: data,\n                key: column,\n                isScrolling: useIsScrolling ? unref(states).isScrolling : void 0,\n                style: getItemStyle(row, column),\n                rowIndex: row\n              }));\n            }\n          }\n        }\n\n        return children;\n      };\n\n      var renderInner = function renderInner() {\n        var Inner = resolveDynamicComponent(props.innerElement);\n        var children = renderItems();\n        return [h(Inner, {\n          style: unref(innerStyle),\n          ref: innerRef\n        }, !isString(Inner) ? {\n          \"default\": function _default() {\n            return children;\n          }\n        } : children)];\n      };\n\n      var renderWindow = function renderWindow() {\n        var Container = resolveDynamicComponent(props.containerElement);\n\n        var _renderScrollbars = renderScrollbars(),\n            horizontalScrollbar = _renderScrollbars.horizontalScrollbar,\n            verticalScrollbar = _renderScrollbars.verticalScrollbar;\n\n        var Inner = renderInner();\n        return h(\"div\", {\n          key: 0,\n          \"class\": \"el-vg__wrapper\"\n        }, [h(Container, {\n          \"class\": props.className,\n          style: unref(windowStyle),\n          onScroll: onScroll,\n          onWheel: onWheel,\n          ref: windowRef\n        }, !isString(Container) ? {\n          \"default\": function _default() {\n            return Inner;\n          }\n        } : Inner), horizontalScrollbar, verticalScrollbar]);\n      };\n\n      return renderWindow;\n    }\n  });\n};\n\nexport { createGrid as default };","map":null,"metadata":{},"sourceType":"module"}