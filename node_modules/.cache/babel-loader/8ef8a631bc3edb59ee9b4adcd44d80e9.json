{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { defineComponent, getCurrentInstance, ref, computed, unref, nextTick, onMounted, onUpdated, resolveDynamicComponent, h } from 'vue';\nimport { hasOwn, isString } from '@vue/shared';\nimport { isNumber } from '../../../../utils/util.mjs';\nimport isServer from '../../../../utils/isServer.mjs';\nimport { useCache } from '../hooks/use-cache.mjs';\nimport useWheel from '../hooks/use-wheel.mjs';\nimport ScrollBar from '../components/scrollbar.mjs';\nimport { isHorizontal, getScrollDir, getRTLOffsetType } from '../utils.mjs';\nimport { virtualizedListProps } from '../props.mjs';\nimport { ITEM_RENDER_EVT, SCROLL_EVT, BACKWARD, FORWARD, RTL, RTL_OFFSET_POS_DESC, RTL_OFFSET_NAG, AUTO_ALIGNMENT, HORIZONTAL } from '../defaults.mjs';\n\nvar createList = function createList(_ref) {\n  var name = _ref.name,\n      getOffset = _ref.getOffset,\n      getItemSize = _ref.getItemSize,\n      getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initCache = _ref.initCache,\n      clearCache = _ref.clearCache,\n      validateProps = _ref.validateProps;\n  return defineComponent({\n    name: name != null ? name : \"ElVirtualList\",\n    props: virtualizedListProps,\n    emits: [ITEM_RENDER_EVT, SCROLL_EVT],\n    setup: function setup(props, _ref2) {\n      var emit = _ref2.emit,\n          expose = _ref2.expose;\n      validateProps(props);\n      var instance = getCurrentInstance();\n      var dynamicSizeCache = ref(initCache(props, instance));\n      var getItemStyleCache = useCache();\n      var windowRef = ref();\n      var innerRef = ref();\n      var scrollbarRef = ref();\n      var states = ref({\n        isScrolling: false,\n        scrollDir: \"forward\",\n        scrollOffset: isNumber(props.initScrollOffset) ? props.initScrollOffset : 0,\n        updateRequested: false,\n        isScrollbarDragging: false,\n        scrollbarAlwaysOn: props.scrollbarAlwaysOn\n      });\n      var itemsToRender = computed(function () {\n        var total = props.total,\n            cache = props.cache;\n\n        var _unref = unref(states),\n            isScrolling = _unref.isScrolling,\n            scrollDir = _unref.scrollDir,\n            scrollOffset = _unref.scrollOffset;\n\n        if (total === 0) {\n          return [0, 0, 0, 0];\n        }\n\n        var startIndex = getStartIndexForOffset(props, scrollOffset, unref(dynamicSizeCache));\n        var stopIndex = getStopIndexForStartIndex(props, startIndex, scrollOffset, unref(dynamicSizeCache));\n        var cacheBackward = !isScrolling || scrollDir === BACKWARD ? Math.max(1, cache) : 1;\n        var cacheForward = !isScrolling || scrollDir === FORWARD ? Math.max(1, cache) : 1;\n        return [Math.max(0, startIndex - cacheBackward), Math.max(0, Math.min(total - 1, stopIndex + cacheForward)), startIndex, stopIndex];\n      });\n      var estimatedTotalSize = computed(function () {\n        return getEstimatedTotalSize(props, unref(dynamicSizeCache));\n      });\n\n      var _isHorizontal = computed(function () {\n        return isHorizontal(props.layout);\n      });\n\n      var windowStyle = computed(function () {\n        return [{\n          position: \"relative\",\n          overflow: \"hidden\",\n          WebkitOverflowScrolling: \"touch\",\n          willChange: \"transform\"\n        }, {\n          direction: props.direction,\n          height: isNumber(props.height) ? \"\".concat(props.height, \"px\") : props.height,\n          width: isNumber(props.width) ? \"\".concat(props.width, \"px\") : props.width\n        }, props.style];\n      });\n      var innerStyle = computed(function () {\n        var size = unref(estimatedTotalSize);\n        var horizontal = unref(_isHorizontal);\n        return {\n          height: horizontal ? \"100%\" : \"\".concat(size, \"px\"),\n          pointerEvents: unref(states).isScrolling ? \"none\" : void 0,\n          width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n        };\n      });\n      var clientSize = computed(function () {\n        return _isHorizontal.value ? props.width : props.height;\n      });\n\n      var _useWheel = useWheel({\n        atStartEdge: computed(function () {\n          return states.value.scrollOffset <= 0;\n        }),\n        atEndEdge: computed(function () {\n          return states.value.scrollOffset >= estimatedTotalSize.value;\n        }),\n        layout: computed(function () {\n          return props.layout;\n        })\n      }, function (offset) {\n        var _a, _b;\n\n        ;\n        (_b = (_a = scrollbarRef.value).onMouseUp) == null ? void 0 : _b.call(_a);\n        scrollTo(Math.min(states.value.scrollOffset + offset, estimatedTotalSize.value - clientSize.value));\n      }),\n          onWheel = _useWheel.onWheel;\n\n      var emitEvents = function emitEvents() {\n        var total = props.total;\n\n        if (total > 0) {\n          var _unref2 = unref(itemsToRender),\n              _unref3 = _slicedToArray(_unref2, 4),\n              cacheStart = _unref3[0],\n              cacheEnd = _unref3[1],\n              visibleStart = _unref3[2],\n              visibleEnd = _unref3[3];\n\n          emit(ITEM_RENDER_EVT, cacheStart, cacheEnd, visibleStart, visibleEnd);\n        }\n\n        var _unref4 = unref(states),\n            scrollDir = _unref4.scrollDir,\n            scrollOffset = _unref4.scrollOffset,\n            updateRequested = _unref4.updateRequested;\n\n        emit(SCROLL_EVT, scrollDir, scrollOffset, updateRequested);\n      };\n\n      var scrollVertically = function scrollVertically(e) {\n        var _e$currentTarget = e.currentTarget,\n            clientHeight = _e$currentTarget.clientHeight,\n            scrollHeight = _e$currentTarget.scrollHeight,\n            scrollTop = _e$currentTarget.scrollTop;\n\n        var _states = unref(states);\n\n        if (_states.scrollOffset === scrollTop) {\n          return;\n        }\n\n        var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      var scrollHorizontally = function scrollHorizontally(e) {\n        var _e$currentTarget2 = e.currentTarget,\n            clientWidth = _e$currentTarget2.clientWidth,\n            scrollLeft = _e$currentTarget2.scrollLeft,\n            scrollWidth = _e$currentTarget2.scrollWidth;\n\n        var _states = unref(states);\n\n        if (_states.scrollOffset === scrollLeft) {\n          return;\n        }\n\n        var direction = props.direction;\n        var scrollOffset = scrollLeft;\n\n        if (direction === RTL) {\n          switch (getRTLOffsetType()) {\n            case RTL_OFFSET_NAG:\n              {\n                scrollOffset = -scrollLeft;\n                break;\n              }\n\n            case RTL_OFFSET_POS_DESC:\n              {\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n              }\n          }\n        }\n\n        scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n        states.value = _objectSpread(_objectSpread({}, _states), {}, {\n          isScrolling: true,\n          scrollDir: getScrollDir(_states.scrollOffset, scrollOffset),\n          scrollOffset: scrollOffset,\n          updateRequested: false\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      var onScroll = function onScroll(e) {\n        unref(_isHorizontal) ? scrollHorizontally(e) : scrollVertically(e);\n        emitEvents();\n      };\n\n      var onScrollbarScroll = function onScrollbarScroll(distanceToGo, totalSteps) {\n        var offset = (estimatedTotalSize.value - clientSize.value) / totalSteps * distanceToGo;\n        scrollTo(Math.min(estimatedTotalSize.value - clientSize.value, offset));\n      };\n\n      var scrollTo = function scrollTo(offset) {\n        offset = Math.max(offset, 0);\n\n        if (offset === unref(states).scrollOffset) {\n          return;\n        }\n\n        states.value = _objectSpread(_objectSpread({}, unref(states)), {}, {\n          scrollOffset: offset,\n          scrollDir: getScrollDir(unref(states).scrollOffset, offset),\n          updateRequested: true\n        });\n        nextTick(resetIsScrolling);\n      };\n\n      var scrollToItem = function scrollToItem(idx) {\n        var alignment = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AUTO_ALIGNMENT;\n\n        var _unref5 = unref(states),\n            scrollOffset = _unref5.scrollOffset;\n\n        idx = Math.max(0, Math.min(idx, props.total - 1));\n        scrollTo(getOffset(props, idx, alignment, scrollOffset, unref(dynamicSizeCache)));\n      };\n\n      var getItemStyle = function getItemStyle(idx) {\n        var direction = props.direction,\n            itemSize = props.itemSize,\n            layout = props.layout;\n        var itemStyleCache = getItemStyleCache.value(clearCache && itemSize, clearCache && layout, clearCache && direction);\n        var style;\n\n        if (hasOwn(itemStyleCache, String(idx))) {\n          style = itemStyleCache[idx];\n        } else {\n          var offset = getItemOffset(props, idx, unref(dynamicSizeCache));\n          var size = getItemSize(props, idx, unref(dynamicSizeCache));\n          var horizontal = unref(_isHorizontal);\n          var isRtl = direction === RTL;\n          var offsetHorizontal = horizontal ? offset : 0;\n          itemStyleCache[idx] = style = {\n            position: \"absolute\",\n            left: isRtl ? void 0 : \"\".concat(offsetHorizontal, \"px\"),\n            right: isRtl ? \"\".concat(offsetHorizontal, \"px\") : void 0,\n            top: !horizontal ? \"\".concat(offset, \"px\") : 0,\n            height: !horizontal ? \"\".concat(size, \"px\") : \"100%\",\n            width: horizontal ? \"\".concat(size, \"px\") : \"100%\"\n          };\n        }\n\n        return style;\n      };\n\n      var resetIsScrolling = function resetIsScrolling() {\n        states.value.isScrolling = false;\n        nextTick(function () {\n          getItemStyleCache.value(-1, null, null);\n        });\n      };\n\n      var resetScrollTop = function resetScrollTop() {\n        var window = windowRef.value;\n\n        if (window) {\n          window.scrollTop = 0;\n        }\n      };\n\n      onMounted(function () {\n        if (isServer) return;\n        var initScrollOffset = props.initScrollOffset;\n        var windowElement = unref(windowRef);\n\n        if (isNumber(initScrollOffset) && windowElement) {\n          if (unref(_isHorizontal)) {\n            windowElement.scrollLeft = initScrollOffset;\n          } else {\n            windowElement.scrollTop = initScrollOffset;\n          }\n        }\n\n        emitEvents();\n      });\n      onUpdated(function () {\n        var direction = props.direction,\n            layout = props.layout;\n\n        var _unref6 = unref(states),\n            scrollOffset = _unref6.scrollOffset,\n            updateRequested = _unref6.updateRequested;\n\n        var windowElement = unref(windowRef);\n\n        if (updateRequested && windowElement) {\n          if (layout === HORIZONTAL) {\n            if (direction === RTL) {\n              switch (getRTLOffsetType()) {\n                case \"negative\":\n                  {\n                    windowElement.scrollLeft = -scrollOffset;\n                    break;\n                  }\n\n                case \"positive-ascending\":\n                  {\n                    windowElement.scrollLeft = scrollOffset;\n                    break;\n                  }\n\n                default:\n                  {\n                    var clientWidth = windowElement.clientWidth,\n                        scrollWidth = windowElement.scrollWidth;\n                    windowElement.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                    break;\n                  }\n              }\n            } else {\n              windowElement.scrollLeft = scrollOffset;\n            }\n          } else {\n            windowElement.scrollTop = scrollOffset;\n          }\n        }\n      });\n      var api = {\n        clientSize: clientSize,\n        estimatedTotalSize: estimatedTotalSize,\n        windowStyle: windowStyle,\n        windowRef: windowRef,\n        innerRef: innerRef,\n        innerStyle: innerStyle,\n        itemsToRender: itemsToRender,\n        scrollbarRef: scrollbarRef,\n        states: states,\n        getItemStyle: getItemStyle,\n        onScroll: onScroll,\n        onScrollbarScroll: onScrollbarScroll,\n        onWheel: onWheel,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop\n      };\n      expose({\n        windowRef: windowRef,\n        innerRef: innerRef,\n        getItemStyleCache: getItemStyleCache,\n        scrollTo: scrollTo,\n        scrollToItem: scrollToItem,\n        resetScrollTop: resetScrollTop,\n        states: states\n      });\n      return api;\n    },\n    render: function render(ctx) {\n      var _a;\n\n      var $slots = ctx.$slots,\n          className = ctx.className,\n          clientSize = ctx.clientSize,\n          containerElement = ctx.containerElement,\n          data = ctx.data,\n          getItemStyle = ctx.getItemStyle,\n          innerElement = ctx.innerElement,\n          itemsToRender = ctx.itemsToRender,\n          innerStyle = ctx.innerStyle,\n          layout = ctx.layout,\n          total = ctx.total,\n          onScroll = ctx.onScroll,\n          onScrollbarScroll = ctx.onScrollbarScroll,\n          onWheel = ctx.onWheel,\n          states = ctx.states,\n          useIsScrolling = ctx.useIsScrolling,\n          windowStyle = ctx.windowStyle;\n\n      var _itemsToRender = _slicedToArray(itemsToRender, 2),\n          start = _itemsToRender[0],\n          end = _itemsToRender[1];\n\n      var Container = resolveDynamicComponent(containerElement);\n      var Inner = resolveDynamicComponent(innerElement);\n      var children = [];\n\n      if (total > 0) {\n        for (var i = start; i <= end; i++) {\n          children.push((_a = $slots[\"default\"]) == null ? void 0 : _a.call($slots, {\n            data: data,\n            key: i,\n            index: i,\n            isScrolling: useIsScrolling ? states.isScrolling : void 0,\n            style: getItemStyle(i)\n          }));\n        }\n      }\n\n      var InnerNode = [h(Inner, {\n        style: innerStyle,\n        ref: \"innerRef\"\n      }, !isString(Inner) ? {\n        \"default\": function _default() {\n          return children;\n        }\n      } : children)];\n      var scrollbar = h(ScrollBar, {\n        ref: \"scrollbarRef\",\n        clientSize: clientSize,\n        layout: layout,\n        onScroll: onScrollbarScroll,\n        ratio: clientSize * 100 / this.estimatedTotalSize,\n        scrollFrom: states.scrollOffset / (this.estimatedTotalSize - clientSize),\n        total: total\n      });\n      var listContainer = h(Container, {\n        \"class\": className,\n        style: windowStyle,\n        onScroll: onScroll,\n        onWheel: onWheel,\n        ref: \"windowRef\",\n        key: 0\n      }, !isString(Container) ? {\n        \"default\": function _default() {\n          return [InnerNode];\n        }\n      } : [InnerNode]);\n      return h(\"div\", {\n        key: 0,\n        \"class\": [\"el-vl__wrapper\", states.scrollbarAlwaysOn ? \"always-on\" : \"\"]\n      }, [listContainer, scrollbar]);\n    }\n  });\n};\n\nexport { createList as default };","map":null,"metadata":{},"sourceType":"module"}