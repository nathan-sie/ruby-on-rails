{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { nextTick } from 'vue';\nimport { isFunction } from '@vue/shared';\nimport throttle from 'lodash/throttle';\nimport { getOffsetTopDistance, getScrollContainer } from '../../../utils/dom.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nvar SCOPE = \"ElInfiniteScroll\";\nvar CHECK_INTERVAL = 50;\nvar DEFAULT_DELAY = 200;\nvar DEFAULT_DISTANCE = 0;\nvar attributes = {\n  delay: {\n    type: Number,\n    \"default\": DEFAULT_DELAY\n  },\n  distance: {\n    type: Number,\n    \"default\": DEFAULT_DISTANCE\n  },\n  disabled: {\n    type: Boolean,\n    \"default\": false\n  },\n  immediate: {\n    type: Boolean,\n    \"default\": true\n  }\n};\n\nvar getScrollOptions = function getScrollOptions(el, instance) {\n  return Object.entries(attributes).reduce(function (acm, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        name = _ref2[0],\n        option = _ref2[1];\n\n    var _a, _b;\n\n    var type = option.type,\n        defaultValue = option[\"default\"];\n    var attrVal = el.getAttribute(\"infinite-scroll-\".concat(name));\n    var value = (_b = (_a = instance[attrVal]) != null ? _a : attrVal) != null ? _b : defaultValue;\n    value = value === \"false\" ? false : value;\n    value = type(value);\n    acm[name] = Number.isNaN(value) ? defaultValue : value;\n    return acm;\n  }, {});\n};\n\nvar destroyObserver = function destroyObserver(el) {\n  var observer = el[SCOPE].observer;\n\n  if (observer) {\n    observer.disconnect();\n    delete el[SCOPE].observer;\n  }\n};\n\nvar handleScroll = function handleScroll(el, cb) {\n  var _el$SCOPE = el[SCOPE],\n      container = _el$SCOPE.container,\n      containerEl = _el$SCOPE.containerEl,\n      instance = _el$SCOPE.instance,\n      observer = _el$SCOPE.observer,\n      lastScrollTop = _el$SCOPE.lastScrollTop;\n\n  var _getScrollOptions = getScrollOptions(el, instance),\n      disabled = _getScrollOptions.disabled,\n      distance = _getScrollOptions.distance;\n\n  var clientHeight = containerEl.clientHeight,\n      scrollHeight = containerEl.scrollHeight,\n      scrollTop = containerEl.scrollTop;\n  var delta = scrollTop - lastScrollTop;\n  el[SCOPE].lastScrollTop = scrollTop;\n  if (observer || disabled || delta < 0) return;\n  var shouldTrigger = false;\n\n  if (container === el) {\n    shouldTrigger = scrollHeight - (clientHeight + scrollTop) <= distance;\n  } else {\n    var clientTop = el.clientTop,\n        height = el.scrollHeight;\n    var offsetTop = getOffsetTopDistance(el, containerEl);\n    shouldTrigger = scrollTop + clientHeight >= offsetTop + clientTop + height - distance;\n  }\n\n  if (shouldTrigger) {\n    cb.call(instance);\n  }\n};\n\nfunction checkFull(el, cb) {\n  var _el$SCOPE2 = el[SCOPE],\n      containerEl = _el$SCOPE2.containerEl,\n      instance = _el$SCOPE2.instance;\n\n  var _getScrollOptions2 = getScrollOptions(el, instance),\n      disabled = _getScrollOptions2.disabled;\n\n  if (disabled) return;\n\n  if (containerEl.scrollHeight <= containerEl.clientHeight) {\n    cb.call(instance);\n  } else {\n    destroyObserver(el);\n  }\n}\n\nvar InfiniteScroll = {\n  mounted: function mounted(el, binding) {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var instance, cb, _getScrollOptions3, delay, immediate, container, containerEl, onScroll, observer;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              instance = binding.instance, cb = binding.value;\n\n              if (!isFunction(cb)) {\n                throwError(SCOPE, \"'v-infinite-scroll' binding value must be a function\");\n              }\n\n              _context.next = 4;\n              return nextTick();\n\n            case 4:\n              _getScrollOptions3 = getScrollOptions(el, instance), delay = _getScrollOptions3.delay, immediate = _getScrollOptions3.immediate;\n              container = getScrollContainer(el, true);\n              containerEl = container === window ? document.documentElement : container;\n              onScroll = throttle(handleScroll.bind(null, el, cb), delay);\n\n              if (container) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 10:\n              el[SCOPE] = {\n                instance: instance,\n                container: container,\n                containerEl: containerEl,\n                delay: delay,\n                cb: cb,\n                onScroll: onScroll,\n                lastScrollTop: containerEl.scrollTop\n              };\n\n              if (immediate) {\n                observer = new MutationObserver(throttle(checkFull.bind(null, el, cb), CHECK_INTERVAL));\n                el[SCOPE].observer = observer;\n                observer.observe(el, {\n                  childList: true,\n                  subtree: true\n                });\n                checkFull(el, cb);\n              }\n\n              container.addEventListener(\"scroll\", onScroll);\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  unmounted: function unmounted(el) {\n    var _el$SCOPE3 = el[SCOPE],\n        container = _el$SCOPE3.container,\n        onScroll = _el$SCOPE3.onScroll;\n    container == null ? void 0 : container.removeEventListener(\"scroll\", onScroll);\n    destroyObserver(el);\n  }\n};\nexport { CHECK_INTERVAL, DEFAULT_DELAY, DEFAULT_DISTANCE, SCOPE, InfiniteScroll as default };","map":null,"metadata":{},"sourceType":"module"}