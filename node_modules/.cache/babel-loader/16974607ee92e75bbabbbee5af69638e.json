{"ast":null,"code":"function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { defineComponent, inject, ref, getCurrentInstance, computed, watch, nextTick, reactive, toRefs, onMounted, onBeforeUnmount, provide } from 'vue';\nimport { NOOP } from '@vue/shared';\nimport AsyncValidator from 'async-validator';\nimport { useGlobalConfig, addUnit, getPropByPath } from '../../../utils/util.mjs';\nimport { isValidComponentSize } from '../../../utils/validators.mjs';\nimport '../../../tokens/index.mjs';\nimport LabelWrap from './label-wrap.mjs';\nimport { elFormKey, elFormItemKey } from '../../../tokens/form.mjs';\nvar script = defineComponent({\n  name: \"ElFormItem\",\n  componentName: \"ElFormItem\",\n  components: {\n    LabelWrap: LabelWrap\n  },\n  props: {\n    label: String,\n    labelWidth: {\n      type: [String, Number],\n      \"default\": \"\"\n    },\n    prop: String,\n    required: {\n      type: Boolean,\n      \"default\": void 0\n    },\n    rules: [Object, Array],\n    error: String,\n    validateStatus: String,\n    \"for\": String,\n    inlineMessage: {\n      type: [String, Boolean],\n      \"default\": \"\"\n    },\n    showMessage: {\n      type: Boolean,\n      \"default\": true\n    },\n    size: {\n      type: String,\n      validator: isValidComponentSize\n    }\n  },\n  setup: function setup(props, _ref) {\n    var slots = _ref.slots;\n    var $ELEMENT = useGlobalConfig();\n    var elForm = inject(elFormKey, {});\n    var validateState = ref(\"\");\n    var validateMessage = ref(\"\");\n    var isValidationEnabled = ref(false);\n    var computedLabelWidth = ref(\"\");\n    var formItemRef = ref();\n    var vm = getCurrentInstance();\n    var isNested = computed(function () {\n      var parent = vm.parent;\n\n      while (parent && parent.type.name !== \"ElForm\") {\n        if (parent.type.name === \"ElFormItem\") {\n          return true;\n        }\n\n        parent = parent.parent;\n      }\n\n      return false;\n    });\n    var initialValue = void 0;\n    watch(function () {\n      return props.error;\n    }, function (val) {\n      validateMessage.value = val;\n      validateState.value = val ? \"error\" : \"\";\n    }, {\n      immediate: true\n    });\n    watch(function () {\n      return props.validateStatus;\n    }, function (val) {\n      validateState.value = val;\n    });\n    var labelFor = computed(function () {\n      return props[\"for\"] || props.prop;\n    });\n    var labelStyle = computed(function () {\n      var ret = {};\n      if (elForm.labelPosition === \"top\") return ret;\n      var labelWidth = addUnit(props.labelWidth || elForm.labelWidth);\n\n      if (labelWidth) {\n        ret.width = labelWidth;\n      }\n\n      return ret;\n    });\n    var contentStyle = computed(function () {\n      var ret = {};\n\n      if (elForm.labelPosition === \"top\" || elForm.inline) {\n        return ret;\n      }\n\n      if (!props.label && !props.labelWidth && isNested.value) {\n        return ret;\n      }\n\n      var labelWidth = addUnit(props.labelWidth || elForm.labelWidth);\n\n      if (!props.label && !slots.label) {\n        ret.marginLeft = labelWidth;\n      }\n\n      return ret;\n    });\n    var fieldValue = computed(function () {\n      var model = elForm.model;\n\n      if (!model || !props.prop) {\n        return;\n      }\n\n      var path = props.prop;\n\n      if (path.indexOf(\":\") !== -1) {\n        path = path.replace(/:/, \".\");\n      }\n\n      return getPropByPath(model, path, true).v;\n    });\n    var isRequired = computed(function () {\n      var rules = getRules();\n      var required = false;\n\n      if (rules && rules.length) {\n        rules.every(function (rule) {\n          if (rule.required) {\n            required = true;\n            return false;\n          }\n\n          return true;\n        });\n      }\n\n      return required;\n    });\n    var elFormItemSize = computed(function () {\n      return props.size || elForm.size;\n    });\n    var sizeClass = computed(function () {\n      return elFormItemSize.value || $ELEMENT.size;\n    });\n\n    var validate = function validate(trigger) {\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NOOP;\n\n      if (!isValidationEnabled.value) {\n        callback();\n        return;\n      }\n\n      var rules = getFilteredRule(trigger);\n\n      if ((!rules || rules.length === 0) && props.required === void 0) {\n        callback();\n        return;\n      }\n\n      validateState.value = \"validating\";\n      var descriptor = {};\n\n      if (rules && rules.length > 0) {\n        rules.forEach(function (rule) {\n          delete rule.trigger;\n        });\n      }\n\n      descriptor[props.prop] = rules;\n      var validator = new AsyncValidator(descriptor);\n      var model = {};\n      model[props.prop] = fieldValue.value;\n      validator.validate(model, {\n        firstFields: true\n      }, function (errors, fields) {\n        var _a;\n\n        validateState.value = !errors ? \"success\" : \"error\";\n        validateMessage.value = errors ? errors[0].message || \"\".concat(props.prop, \" is required\") : \"\";\n        callback(validateMessage.value, errors ? fields : {});\n        (_a = elForm.emit) == null ? void 0 : _a.call(elForm, \"validate\", props.prop, !errors, validateMessage.value || null);\n      });\n    };\n\n    var clearValidate = function clearValidate() {\n      validateState.value = \"\";\n      validateMessage.value = \"\";\n    };\n\n    var resetField = function resetField() {\n      var model = elForm.model;\n      var value = fieldValue.value;\n      var path = props.prop;\n\n      if (path.indexOf(\":\") !== -1) {\n        path = path.replace(/:/, \".\");\n      }\n\n      var prop = getPropByPath(model, path, true);\n\n      if (Array.isArray(value)) {\n        prop.o[prop.k] = [].concat(initialValue);\n      } else {\n        prop.o[prop.k] = initialValue;\n      }\n\n      nextTick(function () {\n        clearValidate();\n      });\n    };\n\n    var getRules = function getRules() {\n      var formRules = elForm.rules;\n      var selfRules = props.rules;\n      var requiredRule = props.required !== void 0 ? {\n        required: !!props.required\n      } : [];\n      var prop = getPropByPath(formRules, props.prop || \"\", false);\n      var normalizedRule = formRules ? prop.o[props.prop || \"\"] || prop.v : [];\n      return [].concat(selfRules || normalizedRule || []).concat(requiredRule);\n    };\n\n    var getFilteredRule = function getFilteredRule(trigger) {\n      var rules = getRules();\n      return rules.filter(function (rule) {\n        if (!rule.trigger || trigger === \"\") return true;\n\n        if (Array.isArray(rule.trigger)) {\n          return rule.trigger.indexOf(trigger) > -1;\n        } else {\n          return rule.trigger === trigger;\n        }\n      }).map(function (rule) {\n        return _objectSpread({}, rule);\n      });\n    };\n\n    var evaluateValidationEnabled = function evaluateValidationEnabled() {\n      var _a;\n\n      isValidationEnabled.value = !!((_a = getRules()) == null ? void 0 : _a.length);\n    };\n\n    var updateComputedLabelWidth = function updateComputedLabelWidth(width) {\n      computedLabelWidth.value = width ? \"\".concat(width, \"px\") : \"\";\n    };\n\n    var elFormItem = reactive(_objectSpread(_objectSpread({}, toRefs(props)), {}, {\n      size: sizeClass,\n      validateState: validateState,\n      $el: formItemRef,\n      evaluateValidationEnabled: evaluateValidationEnabled,\n      resetField: resetField,\n      clearValidate: clearValidate,\n      validate: validate,\n      updateComputedLabelWidth: updateComputedLabelWidth\n    }));\n    onMounted(function () {\n      if (props.prop) {\n        elForm == null ? void 0 : elForm.addField(elFormItem);\n        var value = fieldValue.value;\n        initialValue = Array.isArray(value) ? _toConsumableArray(value) : value;\n        evaluateValidationEnabled();\n      }\n    });\n    onBeforeUnmount(function () {\n      elForm == null ? void 0 : elForm.removeField(elFormItem);\n    });\n    provide(elFormItemKey, elFormItem);\n    var formItemClass = computed(function () {\n      return [{\n        \"el-form-item--feedback\": elForm.statusIcon,\n        \"is-error\": validateState.value === \"error\",\n        \"is-validating\": validateState.value === \"validating\",\n        \"is-success\": validateState.value === \"success\",\n        \"is-required\": isRequired.value || props.required,\n        \"is-no-asterisk\": elForm.hideRequiredAsterisk\n      }, sizeClass.value ? \"el-form-item--\".concat(sizeClass.value) : \"\"];\n    });\n    var shouldShowError = computed(function () {\n      return validateState.value === \"error\" && props.showMessage && elForm.showMessage;\n    });\n    return {\n      formItemRef: formItemRef,\n      formItemClass: formItemClass,\n      shouldShowError: shouldShowError,\n      elForm: elForm,\n      labelStyle: labelStyle,\n      contentStyle: contentStyle,\n      validateMessage: validateMessage,\n      labelFor: labelFor,\n      resetField: resetField,\n      clearValidate: clearValidate\n    };\n  }\n});\nexport { script as default };","map":null,"metadata":{},"sourceType":"module"}