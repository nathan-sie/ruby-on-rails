{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nimport { computed, unref, watch, ref, customRef, isVue3, isRef, effectScope, getCurrentScope, onScopeDispose, shallowRef, watchSyncEffect, readonly, reactive, toRef, isVue2, set as set$1, toRefs as toRefs$1, getCurrentInstance, onBeforeUnmount, onMounted, nextTick, onUnmounted } from 'vue-demi';\n\nfunction and() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return computed(function () {\n    return args.every(function (i) {\n      return unref(i);\n    });\n  });\n}\n\nfunction biSyncRef(a, b) {\n  var flush = \"sync\";\n  var stop1 = watch(a, function (newValue) {\n    b.value = newValue;\n  }, {\n    flush: flush,\n    immediate: true\n  });\n  var stop2 = watch(b, function (newValue) {\n    a.value = newValue;\n  }, {\n    flush: flush,\n    immediate: true\n  });\n  return function () {\n    stop1();\n    stop2();\n  };\n}\n\nfunction controlledComputed(source, fn) {\n  var v = void 0;\n  var track;\n  var trigger;\n  var dirty = ref(true);\n  watch(source, function () {\n    dirty.value = true;\n    trigger();\n  }, {\n    flush: \"sync\"\n  });\n  return customRef(function (_track, _trigger) {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get: function get() {\n        if (dirty.value) {\n          v = fn();\n          dirty.value = false;\n        }\n\n        track();\n        return v;\n      },\n      set: function set() {}\n    };\n  });\n}\n\nfunction __onlyVue3() {\n  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"this function\";\n  if (isVue3) return;\n  throw new Error(\"[VueUse] \".concat(name, \" is only works on Vue 3.\"));\n}\n\nfunction extendRef(ref, extend) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref$enumerable = _ref.enumerable,\n      enumerable = _ref$enumerable === void 0 ? false : _ref$enumerable,\n      _ref$unwrap = _ref.unwrap,\n      unwrap = _ref$unwrap === void 0 ? true : _ref$unwrap;\n\n  __onlyVue3();\n\n  var _loop = function _loop() {\n    var _ref2 = _Object$entries[_i2];\n    _ref3 = _slicedToArray(_ref2, 2);\n    var key = _ref3[0];\n    var value = _ref3[1];\n    if (key === \"value\") return \"continue\";\n\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get: function get() {\n          return value.value;\n        },\n        set: function set(v) {\n          value.value = v;\n        },\n        enumerable: enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, {\n        value: value,\n        enumerable: enumerable\n      });\n    }\n  };\n\n  for (var _i2 = 0, _Object$entries = Object.entries(extend); _i2 < _Object$entries.length; _i2++) {\n    var _ref3;\n\n    var _ret = _loop();\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return ref;\n}\n\nfunction controlledRef(initial) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var source = initial;\n  var track;\n  var trigger;\n  var ref = customRef(function (_track, _trigger) {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get: function get() {\n        return _get();\n      },\n      set: function set(v) {\n        _set(v);\n      }\n    };\n  });\n\n  function _get() {\n    var tracking = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (tracking) track();\n    return source;\n  }\n\n  function _set(value) {\n    var triggering = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var _a, _b;\n\n    if (value === source) return;\n    var old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false) return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering) trigger();\n  }\n\n  var untrackedGet = function untrackedGet() {\n    return _get(false);\n  };\n\n  var silentSet = function silentSet(v) {\n    return _set(v, false);\n  };\n\n  var peek = function peek() {\n    return _get(false);\n  };\n\n  var lay = function lay(v) {\n    return _set(v, false);\n  };\n\n  return extendRef(ref, {\n    get: _get,\n    set: _set,\n    untrackedGet: untrackedGet,\n    silentSet: silentSet,\n    peek: peek,\n    lay: lay\n  }, {\n    enumerable: true\n  });\n}\n\nfunction createEventHook() {\n  var fns = [];\n\n  var _off = function off(fn) {\n    var index = fns.indexOf(fn);\n    if (index !== -1) fns.splice(index, 1);\n  };\n\n  var on = function on(fn) {\n    fns.push(fn);\n    return {\n      off: function off() {\n        return _off(fn);\n      }\n    };\n  };\n\n  var trigger = function trigger(param) {\n    fns.forEach(function (fn) {\n      return fn(param);\n    });\n  };\n\n  return {\n    on: on,\n    off: _off,\n    trigger: trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  var initialized = false;\n  var state;\n  var scope = effectScope(true);\n  return function () {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n\n    return state;\n  };\n}\n\nfunction reactify(fn) {\n  return function () {\n    var _this = this;\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return computed(function () {\n      return fn.apply(_this, args.map(function (i) {\n        return unref(i);\n      }));\n    });\n  };\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n\n  return false;\n}\n\nfunction createSharedComposable(composable) {\n  var subscribers = 0;\n  var state;\n  var scope;\n\n  var dispose = function dispose() {\n    subscribers -= 1;\n\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n\n  return function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    subscribers += 1;\n\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(function () {\n        return composable.apply(void 0, args);\n      });\n    }\n\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nvar isClient = typeof window !== \"undefined\";\n\nvar isDef = function isDef(val) {\n  return typeof val !== \"undefined\";\n};\n\nvar assert = function assert(condition) {\n  var _console;\n\n  for (var _len4 = arguments.length, infos = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    infos[_key4 - 1] = arguments[_key4];\n  }\n\n  if (!condition) (_console = console).warn.apply(_console, infos);\n};\n\nvar toString = Object.prototype.toString;\n\nvar isBoolean = function isBoolean(val) {\n  return typeof val === \"boolean\";\n};\n\nvar isFunction = function isFunction(val) {\n  return typeof val === \"function\";\n};\n\nvar isNumber = function isNumber(val) {\n  return typeof val === \"number\";\n};\n\nvar isString = function isString(val) {\n  return typeof val === \"string\";\n};\n\nvar isObject = function isObject(val) {\n  return toString.call(val) === \"[object Object]\";\n};\n\nvar isWindow = function isWindow(val) {\n  return typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\n};\n\nvar now = function now() {\n  return Date.now();\n};\n\nvar timestamp = function timestamp() {\n  return +Date.now();\n};\n\nvar clamp = function clamp(n, min, max) {\n  return Math.min(max, Math.max(min, n));\n};\n\nvar noop = function noop() {};\n\nvar rand = function rand(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper() {\n    var _this2 = this;\n\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    filter(function () {\n      return fn.apply(_this2, args);\n    }, {\n      fn: fn,\n      thisArg: this,\n      args: args\n    });\n  }\n\n  return wrapper;\n}\n\nvar bypassFilter = function bypassFilter(invoke) {\n  return invoke();\n};\n\nfunction debounceFilter(ms) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var timer;\n  var maxTimer;\n\n  var filter = function filter(invoke) {\n    var duration = unref(ms);\n    var maxDuration = unref(options.maxWait);\n    if (timer) clearTimeout(timer);\n\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n\n      return invoke();\n    }\n\n    if (maxDuration && !maxTimer) {\n      maxTimer = setTimeout(function () {\n        if (timer) clearTimeout(timer);\n        maxTimer = null;\n        invoke();\n      }, maxDuration);\n    }\n\n    timer = setTimeout(function () {\n      if (maxTimer) clearTimeout(maxTimer);\n      maxTimer = null;\n      invoke();\n    }, duration);\n  };\n\n  return filter;\n}\n\nfunction throttleFilter(ms) {\n  var trailing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var leading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var lastExec = 0;\n  var timer;\n  var preventLeading = !leading;\n\n  var clear = function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n    }\n  };\n\n  var filter = function filter(invoke) {\n    var duration = unref(ms);\n    var elapsed = Date.now() - lastExec;\n    clear();\n\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n\n    if (elapsed > duration) {\n      lastExec = Date.now();\n      if (preventLeading) preventLeading = false;else invoke();\n    } else if (trailing) {\n      timer = setTimeout(function () {\n        lastExec = Date.now();\n        if (!leading) preventLeading = true;\n        clear();\n        invoke();\n      }, duration);\n    }\n\n    if (!leading && !timer) timer = setTimeout(function () {\n      return preventLeading = true;\n    }, duration);\n  };\n\n  return filter;\n}\n\nfunction pausableFilter() {\n  var extendFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : bypassFilter;\n  var isActive = ref(true);\n\n  function pause() {\n    isActive.value = false;\n  }\n\n  function resume() {\n    isActive.value = true;\n  }\n\n  var eventFilter = function eventFilter() {\n    if (isActive.value) extendFilter.apply(void 0, arguments);\n  };\n\n  return {\n    isActive: isActive,\n    pause: pause,\n    resume: resume,\n    eventFilter: eventFilter\n  };\n}\n\nfunction promiseTimeout(ms) {\n  var throwOnTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var reason = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"Timeout\";\n  return new Promise(function (resolve, reject) {\n    if (throwOnTimeout) setTimeout(function () {\n      return reject(reason);\n    }, ms);else setTimeout(resolve, ms);\n  });\n}\n\nfunction identity(arg) {\n  return arg;\n}\n\nfunction createSingletonPromise(fn) {\n  var _promise;\n\n  function wrapper() {\n    if (!_promise) _promise = fn();\n    return _promise;\n  }\n\n  wrapper.reset = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var _prev;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _prev = _promise;\n            _promise = void 0;\n\n            if (!_prev) {\n              _context.next = 5;\n              break;\n            }\n\n            _context.next = 5;\n            return _prev;\n\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return wrapper;\n}\n\nfunction invoke(fn) {\n  return fn();\n}\n\nfunction containsProp(obj) {\n  for (var _len6 = arguments.length, props = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    props[_key6 - 1] = arguments[_key6];\n  }\n\n  return props.some(function (k) {\n    return k in obj;\n  });\n}\n\nfunction increaseWithUnit(target, delta) {\n  var _a;\n\n  if (typeof target === \"number\") return target + delta;\n  var value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  var unit = target.slice(value.length);\n  var result = parseFloat(value) + delta;\n  if (Number.isNaN(result)) return target;\n  return result + unit;\n}\n\nfunction objectPick(obj, keys) {\n  var omitUndefined = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  return keys.reduce(function (n, k) {\n    if (k in obj) {\n      if (!omitUndefined || !obj[k] === void 0) n[k] = obj[k];\n    }\n\n    return n;\n  }, {});\n}\n\nfunction useDebounceFn(fn) {\n  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\nfunction useDebounce(value) {\n  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (ms <= 0) return value;\n  var debounced = ref(value.value);\n  var updater = useDebounceFn(function () {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, function () {\n    return updater();\n  });\n  return debounced;\n}\n\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\n\nvar __objRest$5 = function __objRest$5(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp$9.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols$9) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols$9(source)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$9.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return target;\n};\n\nfunction watchWithFilter(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a = options,\n      _a$eventFilter = _a.eventFilter,\n      eventFilter = _a$eventFilter === void 0 ? bypassFilter : _a$eventFilter,\n      watchOptions = __objRest$5(_a, [\"eventFilter\"]);\n\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$7 = function __defNormalProp$7(obj, key, value) {\n  return key in obj ? __defProp$7(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues$7 = function __spreadValues$7(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$8.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$8) {\n    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols$8(b)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (__propIsEnum$8.call(b, prop)) __defNormalProp$7(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps$4 = function __spreadProps$4(a, b) {\n  return __defProps$4(a, __getOwnPropDescs$4(b));\n};\n\nvar __objRest$4 = function __objRest$4(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp$8.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols$8) {\n    var _iterator3 = _createForOfIteratorHelper(__getOwnPropSymbols$8(source)),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var prop = _step3.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$8.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return target;\n};\n\nfunction debouncedWatch(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a = options,\n      _a$debounce = _a.debounce,\n      debounce = _a$debounce === void 0 ? 0 : _a$debounce,\n      watchOptions = __objRest$4(_a, [\"debounce\"]);\n\n  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$7({}, watchOptions), {\n    eventFilter: debounceFilter(debounce)\n  }));\n}\n\nfunction eagerComputed(fn) {\n  var result = shallowRef();\n  watchSyncEffect(function () {\n    result.value = fn();\n  });\n  return readonly(result);\n}\n\nfunction get(obj, key) {\n  if (key == null) return unref(obj);\n  return unref(obj)[key];\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$6 = function __defNormalProp$6(obj, key, value) {\n  return key in obj ? __defProp$6(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues$6 = function __spreadValues$6(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$7.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$7) {\n    var _iterator4 = _createForOfIteratorHelper(__getOwnPropSymbols$7(b)),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var prop = _step4.value;\n        if (__propIsEnum$7.call(b, prop)) __defNormalProp$6(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps$3 = function __spreadProps$3(a, b) {\n  return __defProps$3(a, __getOwnPropDescs$3(b));\n};\n\nvar __objRest$3 = function __objRest$3(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols$7) {\n    var _iterator5 = _createForOfIteratorHelper(__getOwnPropSymbols$7(source)),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var prop = _step5.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n\n  return target;\n};\n\nfunction ignorableWatch(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a = options,\n      _a$eventFilter2 = _a.eventFilter,\n      eventFilter = _a$eventFilter2 === void 0 ? bypassFilter : _a$eventFilter2,\n      watchOptions = __objRest$3(_a, [\"eventFilter\"]);\n\n  var filteredCb = createFilterWrapper(eventFilter, cb);\n  var ignoreUpdates;\n  var ignorePrevAsyncUpdates;\n  var stop;\n\n  if (watchOptions.flush === \"sync\") {\n    var ignore = ref(false);\n\n    ignorePrevAsyncUpdates = function ignorePrevAsyncUpdates() {};\n\n    ignoreUpdates = function ignoreUpdates(updater) {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n\n    stop = watch(source, function () {\n      if (!ignore.value) filteredCb.apply(void 0, arguments);\n    }, watchOptions);\n  } else {\n    var disposables = [];\n    var ignoreCounter = ref(0);\n    var syncCounter = ref(0);\n\n    ignorePrevAsyncUpdates = function ignorePrevAsyncUpdates() {\n      ignoreCounter.value = syncCounter.value;\n    };\n\n    disposables.push(watch(source, function () {\n      syncCounter.value++;\n    }, __spreadProps$3(__spreadValues$6({}, watchOptions), {\n      flush: \"sync\"\n    })));\n\n    ignoreUpdates = function ignoreUpdates(updater) {\n      var syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n\n    disposables.push(watch(source, function () {\n      var ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore) return;\n      filteredCb.apply(void 0, arguments);\n    }, watchOptions));\n\n    stop = function stop() {\n      disposables.forEach(function (fn) {\n        return fn();\n      });\n    };\n  }\n\n  return {\n    stop: stop,\n    ignoreUpdates: ignoreUpdates,\n    ignorePrevAsyncUpdates: ignorePrevAsyncUpdates\n  };\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$5 = function __defNormalProp$5(obj, key, value) {\n  return key in obj ? __defProp$5(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues$5 = function __spreadValues$5(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$6.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$6) {\n    var _iterator6 = _createForOfIteratorHelper(__getOwnPropSymbols$6(b)),\n        _step6;\n\n    try {\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        var prop = _step6.value;\n        if (__propIsEnum$6.call(b, prop)) __defNormalProp$5(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n\n  return a;\n};\n\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    var clone = __spreadValues$5({}, obj);\n\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value: function value() {\n        var index = 0;\n        return {\n          next: function next() {\n            return {\n              value: arr[index++],\n              done: index > arr.length\n            };\n          }\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign(_toConsumableArray(arr), obj);\n  }\n}\n\nfunction not(v) {\n  return computed(function () {\n    return !unref(v);\n  });\n}\n\nfunction or() {\n  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n    args[_key7] = arguments[_key7];\n  }\n\n  return computed(function () {\n    return args.some(function (i) {\n      return unref(i);\n    });\n  });\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$4 = function __defNormalProp$4(obj, key, value) {\n  return key in obj ? __defProp$4(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues$4 = function __spreadValues$4(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$5.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$5) {\n    var _iterator7 = _createForOfIteratorHelper(__getOwnPropSymbols$5(b)),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var prop = _step7.value;\n        if (__propIsEnum$5.call(b, prop)) __defNormalProp$4(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps$2 = function __spreadProps$2(a, b) {\n  return __defProps$2(a, __getOwnPropDescs$2(b));\n};\n\nvar __objRest$2 = function __objRest$2(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols$5) {\n    var _iterator8 = _createForOfIteratorHelper(__getOwnPropSymbols$5(source)),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var prop = _step8.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n  }\n\n  return target;\n};\n\nfunction pausableWatch(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a = options,\n      filter = _a.eventFilter,\n      watchOptions = __objRest$2(_a, [\"eventFilter\"]);\n\n  var _pausableFilter = pausableFilter(filter),\n      eventFilter = _pausableFilter.eventFilter,\n      pause = _pausableFilter.pause,\n      resume = _pausableFilter.resume,\n      isActive = _pausableFilter.isActive;\n\n  var stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$4({}, watchOptions), {\n    eventFilter: eventFilter\n  }));\n  return {\n    stop: stop,\n    pause: pause,\n    resume: resume,\n    isActive: isActive\n  };\n}\n\nfunction reactifyObject(obj) {\n  var optionsOrKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var keys = [];\n\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    var _keys, _keys2;\n\n    var _optionsOrKeys$includ = optionsOrKeys.includeOwnProperties,\n        includeOwnProperties = _optionsOrKeys$includ === void 0 ? true : _optionsOrKeys$includ;\n\n    (_keys = keys).push.apply(_keys, _toConsumableArray(Object.keys(obj)));\n\n    if (includeOwnProperties) (_keys2 = keys).push.apply(_keys2, _toConsumableArray(Object.getOwnPropertyNames(obj)));\n  }\n\n  return Object.fromEntries(keys.map(function (key) {\n    var value = obj[key];\n    return [key, typeof value === \"function\" ? reactify(value.bind(obj)) : value];\n  }));\n}\n\nfunction reactivePick(obj) {\n  for (var _len8 = arguments.length, keys = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n    keys[_key8 - 1] = arguments[_key8];\n  }\n\n  return reactive(Object.fromEntries(keys.map(function (k) {\n    return [k, toRef(obj, k)];\n  })));\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get: function get() {\n      var _a;\n\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set: function set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction set() {\n  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n    args[_key9] = arguments[_key9];\n  }\n\n  if (args.length === 2) {\n    var _ref5 = args[0],\n        value = args[1];\n    _ref5.value = value;\n  }\n\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1.apply(void 0, args);\n    } else {\n      var target = args[0],\n          key = args[1],\n          _value = args[2];\n      target[key] = _value;\n    }\n  }\n}\n\nfunction syncRef(source, targets) {\n  var _ref6 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref6$flush = _ref6.flush,\n      flush = _ref6$flush === void 0 ? \"sync\" : _ref6$flush,\n      _ref6$deep = _ref6.deep,\n      deep = _ref6$deep === void 0 ? false : _ref6$deep,\n      _ref6$immediate = _ref6.immediate,\n      immediate = _ref6$immediate === void 0 ? true : _ref6$immediate;\n\n  if (!Array.isArray(targets)) targets = [targets];\n  return watch(source, function (newValue) {\n    return targets.forEach(function (target) {\n      return target.value = newValue;\n    });\n  }, {\n    flush: flush,\n    deep: deep,\n    immediate: immediate\n  });\n}\n\nfunction useThrottleFn(fn) {\n  var ms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return createFilterWrapper(throttleFilter(ms, trailing, leading), fn);\n}\n\nfunction useThrottle(value) {\n  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n  var trailing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var leading = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (delay <= 0) return value;\n  var throttled = ref(value.value);\n  var updater = useThrottleFn(function () {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, function () {\n    return updater();\n  });\n  return throttled;\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$3 = function __defNormalProp$3(obj, key, value) {\n  return key in obj ? __defProp$3(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues$3 = function __spreadValues$3(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$4.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$4) {\n    var _iterator9 = _createForOfIteratorHelper(__getOwnPropSymbols$4(b)),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var prop = _step9.value;\n        if (__propIsEnum$4.call(b, prop)) __defNormalProp$3(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps$1 = function __spreadProps$1(a, b) {\n  return __defProps$1(a, __getOwnPropDescs$1(b));\n};\n\nvar __objRest$1 = function __objRest$1(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols$4) {\n    var _iterator10 = _createForOfIteratorHelper(__getOwnPropSymbols$4(source)),\n        _step10;\n\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var prop = _step10.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n  }\n\n  return target;\n};\n\nfunction throttledWatch(source, cb) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a = options,\n      _a$throttle = _a.throttle,\n      throttle = _a$throttle === void 0 ? 0 : _a$throttle,\n      _a$trailing = _a.trailing,\n      trailing = _a$trailing === void 0 ? true : _a$trailing,\n      _a$leading = _a.leading,\n      leading = _a$leading === void 0 ? true : _a$leading,\n      watchOptions = __objRest$1(_a, [\"throttle\", \"trailing\", \"leading\"]);\n\n  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$3({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef)) return reactive(objectRef);\n  var proxy = new Proxy({}, {\n    get: function get(_, p, receiver) {\n      return Reflect.get(objectRef.value, p, receiver);\n    },\n    set: function set(_, p, value) {\n      objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty: function deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has: function has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys: function ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$2 = function __defNormalProp$2(obj, key, value) {\n  return key in obj ? __defProp$2(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues$2 = function __spreadValues$2(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$3.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$3) {\n    var _iterator11 = _createForOfIteratorHelper(__getOwnPropSymbols$3(b)),\n        _step11;\n\n    try {\n      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n        var prop = _step11.value;\n        if (__propIsEnum$3.call(b, prop)) __defNormalProp$2(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator11.e(err);\n    } finally {\n      _iterator11.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\n\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef)) return toRefs$1(objectRef);\n  var result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n\n  var _loop2 = function _loop2(key) {\n    result[key] = customRef(function () {\n      return {\n        get: function get() {\n          return objectRef.value[key];\n        },\n        set: function set(v) {\n          if (Array.isArray(objectRef.value)) {\n            var copy = _toConsumableArray(objectRef.value);\n\n            copy[key] = v;\n            objectRef.value = copy;\n          } else {\n            objectRef.value = __spreadProps(__spreadValues$2({}, objectRef.value), _defineProperty({}, key, v));\n          }\n        }\n      };\n    });\n  };\n\n  for (var key in objectRef.value) {\n    _loop2(key);\n  }\n\n  return result;\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance()) onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn) {\n  var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (getCurrentInstance()) onMounted(fn);else if (sync) fn();else nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance()) onUnmounted(fn);\n}\n\nfunction until(r) {\n  var isNot = false;\n\n  function toMatch(condition) {\n    var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref7$flush = _ref7.flush,\n        flush = _ref7$flush === void 0 ? \"sync\" : _ref7$flush,\n        _ref7$deep = _ref7.deep,\n        deep = _ref7$deep === void 0 ? false : _ref7$deep,\n        timeout = _ref7.timeout,\n        throwOnTimeout = _ref7.throwOnTimeout;\n\n    var stop = null;\n    var watcher = new Promise(function (resolve) {\n      stop = watch(r, function (v) {\n        if (condition(v) === !isNot) {\n          stop == null ? void 0 : stop();\n          resolve();\n        }\n      }, {\n        flush: flush,\n        deep: deep,\n        immediate: true\n      });\n    });\n    var promises = [watcher];\n\n    if (timeout) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout)[\"finally\"](function () {\n        stop == null ? void 0 : stop();\n      }));\n    }\n\n    return Promise.race(promises);\n  }\n\n  function toBe(value, options) {\n    return toMatch(function (v) {\n      return v === unref(value);\n    }, options);\n  }\n\n  function toBeTruthy(options) {\n    return toMatch(function (v) {\n      return Boolean(v);\n    }, options);\n  }\n\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n\n  function toContains(value, options) {\n    return toMatch(function (v) {\n      var array = Array.from(v);\n      return array.includes(value) || array.includes(unref(value));\n    }, options);\n  }\n\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n\n  function changedTimes() {\n    var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var options = arguments.length > 1 ? arguments[1] : undefined;\n    var count = -1;\n    return toMatch(function () {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n\n  if (Array.isArray(unref(r))) {\n    var instance = {\n      toMatch: toMatch,\n      toContains: toContains,\n      changed: changed,\n      changedTimes: changedTimes,\n\n      get not() {\n        isNot = !isNot;\n        return this;\n      }\n\n    };\n    return instance;\n  } else {\n    var _instance = {\n      toMatch: toMatch,\n      toBe: toBe,\n      toBeTruthy: toBeTruthy,\n      toBeNull: toBeNull,\n      toBeNaN: toBeNaN,\n      toBeUndefined: toBeUndefined,\n      changed: changed,\n      changedTimes: changedTimes,\n\n      get not() {\n        isNot = !isNot;\n        return this;\n      }\n\n    };\n    return _instance;\n  }\n}\n\nfunction useCounter() {\n  var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var count = ref(initialValue);\n  var _options$max = options.max,\n      max = _options$max === void 0 ? Infinity : _options$max,\n      _options$min = options.min,\n      min = _options$min === void 0 ? -Infinity : _options$min;\n\n  var inc = function inc() {\n    var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return count.value = Math.min(max, count.value + delta);\n  };\n\n  var dec = function dec() {\n    var delta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    return count.value = Math.max(min, count.value - delta);\n  };\n\n  var get = function get() {\n    return count.value;\n  };\n\n  var set = function set(val) {\n    return count.value = val;\n  };\n\n  var reset = function reset() {\n    var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialValue;\n    initialValue = val;\n    return set(val);\n  };\n\n  return {\n    count: count,\n    inc: inc,\n    dec: dec,\n    get: get,\n    set: set,\n    reset: reset\n  };\n}\n\nfunction useIntervalFn(cb) {\n  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e3;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$immediate = options.immediate,\n      immediate = _options$immediate === void 0 ? true : _options$immediate,\n      _options$immediateCal = options.immediateCallback,\n      immediateCallback = _options$immediateCal === void 0 ? false : _options$immediateCal;\n  var timer = null;\n  var isActive = ref(false);\n\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n\n  function resume() {\n    if (interval <= 0) return;\n    isActive.value = true;\n    if (immediateCallback) cb();\n    clean();\n    timer = setInterval(cb, interval);\n  }\n\n  if (immediate && isClient) resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive: isActive,\n    pause: pause,\n    resume: resume\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp$1 = function __defNormalProp$1(obj, key, value) {\n  return key in obj ? __defProp$1(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues$1 = function __spreadValues$1(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$2.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$2) {\n    var _iterator12 = _createForOfIteratorHelper(__getOwnPropSymbols$2(b)),\n        _step12;\n\n    try {\n      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n        var prop = _step12.value;\n        if (__propIsEnum$2.call(b, prop)) __defNormalProp$1(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator12.e(err);\n    } finally {\n      _iterator12.f();\n    }\n  }\n\n  return a;\n};\n\nfunction useInterval() {\n  var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e3;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$controls = options.controls,\n      exposeControls = _options$controls === void 0 ? false : _options$controls,\n      _options$immediate2 = options.immediate,\n      immediate = _options$immediate2 === void 0 ? true : _options$immediate2;\n  var counter = ref(0);\n  var controls = useIntervalFn(function () {\n    return counter.value += 1;\n  }, interval, {\n    immediate: immediate\n  });\n\n  if (exposeControls) {\n    return __spreadValues$1({\n      counter: counter\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  var ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, function () {\n    return ms.value = timestamp();\n  }, options);\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _options$immediate3 = options.immediate,\n      immediate = _options$immediate3 === void 0 ? true : _options$immediate3;\n  var isPending = ref(false);\n  var timer = null;\n\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n\n  function start() {\n    for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {\n      args[_key10] = arguments[_key10];\n    }\n\n    clear();\n    isPending.value = true;\n    timer = setTimeout(function () {\n      isPending.value = false;\n      timer = null;\n      cb.apply(void 0, args);\n    }, unref(interval));\n  }\n\n  if (immediate) {\n    isPending.value = true;\n    if (isClient) start();\n  }\n\n  tryOnScopeDispose(stop);\n  return {\n    isPending: isPending,\n    start: start,\n    stop: stop\n  };\n}\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp$1.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols$1) {\n    var _iterator13 = _createForOfIteratorHelper(__getOwnPropSymbols$1(b)),\n        _step13;\n\n    try {\n      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n        var prop = _step13.value;\n        if (__propIsEnum$1.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator13.e(err);\n    } finally {\n      _iterator13.f();\n    }\n  }\n\n  return a;\n};\n\nfunction useTimeout() {\n  var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1e3;\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$controls2 = options.controls,\n      exposeControls = _options$controls2 === void 0 ? false : _options$controls2;\n  var controls = useTimeoutFn(noop, interval, options);\n  var ready = computed(function () {\n    return !controls.isPending.value;\n  });\n\n  if (exposeControls) {\n    return __spreadValues({\n      ready: ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToggle() {\n  var initialValue = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n  if (isRef(initialValue)) {\n    return function (value) {\n      initialValue.value = typeof value === \"boolean\" ? value : !initialValue.value;\n    };\n  } else {\n    var _boolean = ref(initialValue);\n\n    var toggle = function toggle(value) {\n      _boolean.value = typeof value === \"boolean\" ? value : !_boolean.value;\n    };\n\n    return [_boolean, toggle];\n  }\n}\n\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator14 = _createForOfIteratorHelper(__getOwnPropSymbols(source)),\n        _step14;\n\n    try {\n      for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n        var prop = _step14.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator14.e(err);\n    } finally {\n      _iterator14.f();\n    }\n  }\n\n  return target;\n};\n\nfunction watchAtMost(source, cb, options) {\n  var _a = options,\n      count = _a.count,\n      watchOptions = __objRest(_a, [\"count\"]);\n\n  var current = ref(0);\n  var stop = watchWithFilter(source, function () {\n    current.value += 1;\n    if (current.value >= unref(count)) stop();\n    cb.apply(void 0, arguments);\n  }, watchOptions);\n  return {\n    count: current,\n    stop: stop\n  };\n}\n\nfunction watchOnce(source, cb, options) {\n  var stop = watch(source, function () {\n    stop();\n    return cb.apply(void 0, arguments);\n  }, options);\n}\n\nfunction whenever(source, cb, options) {\n  return watch(source, function (v, ov, onInvalidate) {\n    if (v) cb(v, ov, onInvalidate);\n  }, options);\n}\n\nexport { and, assert, biSyncRef, bypassFilter, clamp, containsProp, controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, useDebounce as debouncedRef, debouncedWatch, eagerComputed, extendRef, get, identity, ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isNumber, isObject, isString, isWindow, makeDestructurable, noop, not, now, objectPick, or, pausableFilter, pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactivePick, refDefault, set, syncRef, throttleFilter, useThrottle as throttledRef, throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useCounter, useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToggle, watchAtMost, watchOnce, watchWithFilter, whenever };","map":null,"metadata":{},"sourceType":"module"}