{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nimport { reactive } from 'vue';\nimport { hasOwn } from '@vue/shared';\nimport { markNodeData, NODE_KEY } from './util.mjs';\n\nvar getChildState = function getChildState(node) {\n  var all = true;\n  var none = true;\n  var allWithoutDisable = true;\n\n  for (var i = 0, j = node.length; i < j; i++) {\n    var n = node[i];\n\n    if (n.checked !== true || n.indeterminate) {\n      all = false;\n\n      if (!n.disabled) {\n        allWithoutDisable = false;\n      }\n    }\n\n    if (n.checked !== false || n.indeterminate) {\n      none = false;\n    }\n  }\n\n  return {\n    all: all,\n    none: none,\n    allWithoutDisable: allWithoutDisable,\n    half: !all && !none\n  };\n};\n\nvar reInitChecked = function reInitChecked(node) {\n  if (node.childNodes.length === 0) return;\n\n  var _getChildState = getChildState(node.childNodes),\n      all = _getChildState.all,\n      none = _getChildState.none,\n      half = _getChildState.half;\n\n  if (all) {\n    node.checked = true;\n    node.indeterminate = false;\n  } else if (half) {\n    node.checked = false;\n    node.indeterminate = true;\n  } else if (none) {\n    node.checked = false;\n    node.indeterminate = false;\n  }\n\n  var parent = node.parent;\n  if (!parent || parent.level === 0) return;\n\n  if (!node.store.checkStrictly) {\n    reInitChecked(parent);\n  }\n};\n\nvar getPropertyFromData = function getPropertyFromData(node, prop) {\n  var props = node.store.props;\n  var data = node.data || {};\n  var config = props[prop];\n\n  if (typeof config === \"function\") {\n    return config(data, node);\n  } else if (typeof config === \"string\") {\n    return data[config];\n  } else if (typeof config === \"undefined\") {\n    var dataProp = data[prop];\n    return dataProp === void 0 ? \"\" : dataProp;\n  }\n};\n\nvar nodeIdSeed = 0;\n\nvar Node = /*#__PURE__*/function () {\n  function Node(options) {\n    _classCallCheck(this, Node);\n\n    this.id = nodeIdSeed++;\n    this.text = null;\n    this.checked = false;\n    this.indeterminate = false;\n    this.data = null;\n    this.expanded = false;\n    this.parent = null;\n    this.visible = true;\n    this.isCurrent = false;\n    this.canFocus = false;\n\n    for (var name in options) {\n      if (hasOwn(options, name)) {\n        this[name] = options[name];\n      }\n    }\n\n    this.level = 0;\n    this.loaded = false;\n    this.childNodes = [];\n    this.loading = false;\n\n    if (this.parent) {\n      this.level = this.parent.level + 1;\n    }\n  }\n\n  _createClass(Node, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var store = this.store;\n\n      if (!store) {\n        throw new Error(\"[Node]store is required!\");\n      }\n\n      store.registerNode(this);\n      var props = store.props;\n\n      if (props && typeof props.isLeaf !== \"undefined\") {\n        var isLeaf = getPropertyFromData(this, \"isLeaf\");\n\n        if (typeof isLeaf === \"boolean\") {\n          this.isLeafByUser = isLeaf;\n        }\n      }\n\n      if (store.lazy !== true && this.data) {\n        this.setData(this.data);\n\n        if (store.defaultExpandAll) {\n          this.expanded = true;\n          this.canFocus = true;\n        }\n      } else if (this.level > 0 && store.lazy && store.defaultExpandAll) {\n        this.expand();\n      }\n\n      if (!Array.isArray(this.data)) {\n        markNodeData(this, this.data);\n      }\n\n      if (!this.data) return;\n      var defaultExpandedKeys = store.defaultExpandedKeys;\n      var key = store.key;\n\n      if (key && defaultExpandedKeys && defaultExpandedKeys.indexOf(this.key) !== -1) {\n        this.expand(null, store.autoExpandParent);\n      }\n\n      if (key && store.currentNodeKey !== void 0 && this.key === store.currentNodeKey) {\n        store.currentNode = this;\n        store.currentNode.isCurrent = true;\n      }\n\n      if (store.lazy) {\n        store._initDefaultCheckedNode(this);\n      }\n\n      this.updateLeafState();\n      if (this.parent && (this.level === 1 || this.parent.expanded === true)) this.canFocus = true;\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      if (!Array.isArray(data)) {\n        markNodeData(this, data);\n      }\n\n      this.data = data;\n      this.childNodes = [];\n      var children;\n\n      if (this.level === 0 && this.data instanceof Array) {\n        children = this.data;\n      } else {\n        children = getPropertyFromData(this, \"children\") || [];\n      }\n\n      for (var i = 0, j = children.length; i < j; i++) {\n        this.insertChild({\n          data: children[i]\n        });\n      }\n    }\n  }, {\n    key: \"label\",\n    get: function get() {\n      return getPropertyFromData(this, \"label\");\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      var nodeKey = this.store.key;\n      if (this.data) return this.data[nodeKey];\n      return null;\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return getPropertyFromData(this, \"disabled\");\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (parent) {\n        var index = parent.childNodes.indexOf(this);\n\n        if (index > -1) {\n          return parent.childNodes[index + 1];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"previousSibling\",\n    get: function get() {\n      var parent = this.parent;\n\n      if (parent) {\n        var index = parent.childNodes.indexOf(this);\n\n        if (index > -1) {\n          return index > 0 ? parent.childNodes[index - 1] : null;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(target) {\n      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return (this.childNodes || []).some(function (child) {\n        return child === target || deep && child.contains(target);\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var parent = this.parent;\n\n      if (parent) {\n        parent.removeChild(this);\n      }\n    }\n  }, {\n    key: \"insertChild\",\n    value: function insertChild(child, index, batch) {\n      if (!child) throw new Error(\"InsertChild error: child is required.\");\n\n      if (!(child instanceof Node)) {\n        if (!batch) {\n          var children = this.getChildren(true);\n\n          if (children.indexOf(child.data) === -1) {\n            if (typeof index === \"undefined\" || index < 0) {\n              children.push(child.data);\n            } else {\n              children.splice(index, 0, child.data);\n            }\n          }\n        }\n\n        Object.assign(child, {\n          parent: this,\n          store: this.store\n        });\n        child = reactive(new Node(child));\n\n        if (child instanceof Node) {\n          child.initialize();\n        }\n      }\n\n      ;\n      child.level = this.level + 1;\n\n      if (typeof index === \"undefined\" || index < 0) {\n        this.childNodes.push(child);\n      } else {\n        this.childNodes.splice(index, 0, child);\n      }\n\n      this.updateLeafState();\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(child, ref) {\n      var index;\n\n      if (ref) {\n        index = this.childNodes.indexOf(ref);\n      }\n\n      this.insertChild(child, index);\n    }\n  }, {\n    key: \"insertAfter\",\n    value: function insertAfter(child, ref) {\n      var index;\n\n      if (ref) {\n        index = this.childNodes.indexOf(ref);\n        if (index !== -1) index += 1;\n      }\n\n      this.insertChild(child, index);\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      var children = this.getChildren() || [];\n      var dataIndex = children.indexOf(child.data);\n\n      if (dataIndex > -1) {\n        children.splice(dataIndex, 1);\n      }\n\n      var index = this.childNodes.indexOf(child);\n\n      if (index > -1) {\n        this.store && this.store.deregisterNode(child);\n        child.parent = null;\n        this.childNodes.splice(index, 1);\n      }\n\n      this.updateLeafState();\n    }\n  }, {\n    key: \"removeChildByData\",\n    value: function removeChildByData(data) {\n      var targetNode = null;\n\n      for (var i = 0; i < this.childNodes.length; i++) {\n        if (this.childNodes[i].data === data) {\n          targetNode = this.childNodes[i];\n          break;\n        }\n      }\n\n      if (targetNode) {\n        this.removeChild(targetNode);\n      }\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(callback, expandParent) {\n      var _this = this;\n\n      var done = function done() {\n        if (expandParent) {\n          var parent = _this.parent;\n\n          while (parent.level > 0) {\n            parent.expanded = true;\n            parent = parent.parent;\n          }\n        }\n\n        _this.expanded = true;\n        if (callback) callback();\n\n        _this.childNodes.forEach(function (item) {\n          item.canFocus = true;\n        });\n      };\n\n      if (this.shouldLoadData()) {\n        this.loadData(function (data) {\n          if (Array.isArray(data)) {\n            if (_this.checked) {\n              _this.setChecked(true, true);\n            } else if (!_this.store.checkStrictly) {\n              reInitChecked(_this);\n            }\n\n            done();\n          }\n        });\n      } else {\n        done();\n      }\n    }\n  }, {\n    key: \"doCreateChildren\",\n    value: function doCreateChildren(array) {\n      var _this2 = this;\n\n      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      array.forEach(function (item) {\n        _this2.insertChild(Object.assign({\n          data: item\n        }, defaultProps), void 0, true);\n      });\n    }\n  }, {\n    key: \"collapse\",\n    value: function collapse() {\n      this.expanded = false;\n      this.childNodes.forEach(function (item) {\n        item.canFocus = false;\n      });\n    }\n  }, {\n    key: \"shouldLoadData\",\n    value: function shouldLoadData() {\n      return this.store.lazy === true && this.store.load && !this.loaded;\n    }\n  }, {\n    key: \"updateLeafState\",\n    value: function updateLeafState() {\n      if (this.store.lazy === true && this.loaded !== true && typeof this.isLeafByUser !== \"undefined\") {\n        this.isLeaf = this.isLeafByUser;\n        return;\n      }\n\n      var childNodes = this.childNodes;\n\n      if (!this.store.lazy || this.store.lazy === true && this.loaded === true) {\n        this.isLeaf = !childNodes || childNodes.length === 0;\n        return;\n      }\n\n      this.isLeaf = false;\n    }\n  }, {\n    key: \"setChecked\",\n    value: function setChecked(value, deep, recursion, passValue) {\n      var _this3 = this;\n\n      this.indeterminate = value === \"half\";\n      this.checked = value === true;\n      if (this.store.checkStrictly) return;\n\n      if (!(this.shouldLoadData() && !this.store.checkDescendants)) {\n        var _getChildState2 = getChildState(this.childNodes),\n            all = _getChildState2.all,\n            allWithoutDisable = _getChildState2.allWithoutDisable;\n\n        if (!this.isLeaf && !all && allWithoutDisable) {\n          this.checked = false;\n          value = false;\n        }\n\n        var handleDescendants = function handleDescendants() {\n          if (deep) {\n            var childNodes = _this3.childNodes;\n\n            for (var i = 0, j = childNodes.length; i < j; i++) {\n              var child = childNodes[i];\n              passValue = passValue || value !== false;\n              var isCheck = child.disabled ? child.checked : passValue;\n              child.setChecked(isCheck, deep, true, passValue);\n            }\n\n            var _getChildState3 = getChildState(childNodes),\n                half = _getChildState3.half,\n                all2 = _getChildState3.all;\n\n            if (!all2) {\n              _this3.checked = all2;\n              _this3.indeterminate = half;\n            }\n          }\n        };\n\n        if (this.shouldLoadData()) {\n          this.loadData(function () {\n            handleDescendants();\n            reInitChecked(_this3);\n          }, {\n            checked: value !== false\n          });\n          return;\n        } else {\n          handleDescendants();\n        }\n      }\n\n      var parent = this.parent;\n      if (!parent || parent.level === 0) return;\n\n      if (!recursion) {\n        reInitChecked(parent);\n      }\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var forceInit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this.level === 0) return this.data;\n      var data = this.data;\n      if (!data) return null;\n      var props = this.store.props;\n      var children = \"children\";\n\n      if (props) {\n        children = props.children || \"children\";\n      }\n\n      if (data[children] === void 0) {\n        data[children] = null;\n      }\n\n      if (forceInit && !data[children]) {\n        data[children] = [];\n      }\n\n      return data[children];\n    }\n  }, {\n    key: \"updateChildren\",\n    value: function updateChildren() {\n      var _this4 = this;\n\n      var newData = this.getChildren() || [];\n      var oldData = this.childNodes.map(function (node) {\n        return node.data;\n      });\n      var newDataMap = {};\n      var newNodes = [];\n      newData.forEach(function (item, index) {\n        var key = item[NODE_KEY];\n        var isNodeExists = !!key && oldData.findIndex(function (data) {\n          return data[NODE_KEY] === key;\n        }) >= 0;\n\n        if (isNodeExists) {\n          newDataMap[key] = {\n            index: index,\n            data: item\n          };\n        } else {\n          newNodes.push({\n            index: index,\n            data: item\n          });\n        }\n      });\n\n      if (!this.store.lazy) {\n        oldData.forEach(function (item) {\n          if (!newDataMap[item[NODE_KEY]]) _this4.removeChildByData(item);\n        });\n      }\n\n      newNodes.forEach(function (_ref) {\n        var index = _ref.index,\n            data = _ref.data;\n\n        _this4.insertChild({\n          data: data\n        }, index);\n      });\n      this.updateLeafState();\n    }\n  }, {\n    key: \"loadData\",\n    value: function loadData(callback) {\n      var _this5 = this;\n\n      var defaultProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.store.lazy === true && this.store.load && !this.loaded && (!this.loading || Object.keys(defaultProps).length)) {\n        this.loading = true;\n\n        var resolve = function resolve(children) {\n          _this5.loaded = true;\n          _this5.loading = false;\n          _this5.childNodes = [];\n\n          _this5.doCreateChildren(children, defaultProps);\n\n          _this5.updateLeafState();\n\n          if (callback) {\n            callback.call(_this5, children);\n          }\n        };\n\n        this.store.load(this, resolve);\n      } else {\n        if (callback) {\n          callback.call(this);\n        }\n      }\n    }\n  }]);\n\n  return Node;\n}();\n\nexport { Node as default, getChildState };","map":null,"metadata":{},"sourceType":"module"}