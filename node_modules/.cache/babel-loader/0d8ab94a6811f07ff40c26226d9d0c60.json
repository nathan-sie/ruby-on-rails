{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { reactive, ref, shallowRef, inject, computed, watch, nextTick, triggerRef } from 'vue';\nimport { toRawType, isObject } from '@vue/shared';\nimport debounce from 'lodash/debounce';\nimport isEqual from 'lodash/isEqual';\nimport { CHANGE_EVENT, UPDATE_MODEL_EVENT } from '../../../utils/constants.mjs';\nimport { EVENT_CODE } from '../../../utils/aria.mjs';\nimport '../../../hooks/index.mjs';\nimport isServer from '../../../utils/isServer.mjs';\nimport scrollIntoView from '../../../utils/scroll-into-view.mjs';\nimport { isKorean } from '../../../utils/isDef.mjs';\nimport { useGlobalConfig, getValueByPath } from '../../../utils/util.mjs';\nimport '../../../tokens/index.mjs';\nimport { ArrowUp } from '@element-plus/icons';\nimport { useLocaleInject } from '../../../hooks/use-locale/index.mjs';\nimport { elFormKey, elFormItemKey } from '../../../tokens/form.mjs';\n\nfunction useSelectStates(props) {\n  var _useLocaleInject = useLocaleInject(),\n      t = _useLocaleInject.t;\n\n  return reactive({\n    options: new Map(),\n    cachedOptions: new Map(),\n    createdLabel: null,\n    createdSelected: false,\n    selected: props.multiple ? [] : {},\n    inputLength: 20,\n    inputWidth: 0,\n    initialInputHeight: 0,\n    optionsCount: 0,\n    filteredOptionsCount: 0,\n    visible: false,\n    softFocus: false,\n    selectedLabel: \"\",\n    hoverIndex: -1,\n    query: \"\",\n    previousQuery: null,\n    inputHovering: false,\n    cachedPlaceHolder: \"\",\n    currentPlaceholder: t(\"el.select.placeholder\"),\n    menuVisibleOnFocus: false,\n    isOnComposition: false,\n    isSilentBlur: false,\n    prefixWidth: null,\n    tagInMultiLine: false\n  });\n}\n\nvar useSelect = function useSelect(props, states, ctx) {\n  var ELEMENT = useGlobalConfig();\n\n  var _useLocaleInject2 = useLocaleInject(),\n      t = _useLocaleInject2.t;\n\n  var reference = ref(null);\n  var input = ref(null);\n  var popper = ref(null);\n  var tags = ref(null);\n  var selectWrapper = ref(null);\n  var scrollbar = ref(null);\n  var hoverOption = ref(-1);\n  var queryChange = shallowRef({\n    query: \"\"\n  });\n  var groupQueryChange = shallowRef(\"\");\n  var elForm = inject(elFormKey, {});\n  var elFormItem = inject(elFormItemKey, {});\n  var readonly = computed(function () {\n    return !props.filterable || props.multiple || !states.visible;\n  });\n  var selectDisabled = computed(function () {\n    return props.disabled || elForm.disabled;\n  });\n  var showClose = computed(function () {\n    var hasValue = props.multiple ? Array.isArray(props.modelValue) && props.modelValue.length > 0 : props.modelValue !== void 0 && props.modelValue !== null && props.modelValue !== \"\";\n    var criteria = props.clearable && !selectDisabled.value && states.inputHovering && hasValue;\n    return criteria;\n  });\n  var iconComponent = computed(function () {\n    return props.remote && props.filterable ? \"\" : ArrowUp;\n  });\n  var iconReverse = computed(function () {\n    return iconComponent.value && states.visible ? \"is-reverse\" : \"\";\n  });\n  var debounce$1 = computed(function () {\n    return props.remote ? 300 : 0;\n  });\n  var emptyText = computed(function () {\n    if (props.loading) {\n      return props.loadingText || t(\"el.select.loading\");\n    } else {\n      if (props.remote && states.query === \"\" && states.options.size === 0) return false;\n\n      if (props.filterable && states.query && states.options.size > 0 && states.filteredOptionsCount === 0) {\n        return props.noMatchText || t(\"el.select.noMatch\");\n      }\n\n      if (states.options.size === 0) {\n        return props.noDataText || t(\"el.select.noData\");\n      }\n    }\n\n    return null;\n  });\n  var optionsArray = computed(function () {\n    return Array.from(states.options.values());\n  });\n  var cachedOptionsArray = computed(function () {\n    return Array.from(states.cachedOptions.values());\n  });\n  var showNewOption = computed(function () {\n    var hasExistingOption = optionsArray.value.filter(function (option) {\n      return !option.created;\n    }).some(function (option) {\n      return option.currentLabel === states.query;\n    });\n    return props.filterable && props.allowCreate && states.query !== \"\" && !hasExistingOption;\n  });\n  var selectSize = computed(function () {\n    return props.size || elFormItem.size || ELEMENT.size;\n  });\n  var collapseTagSize = computed(function () {\n    return [\"small\", \"mini\"].indexOf(selectSize.value) > -1 ? \"mini\" : \"small\";\n  });\n  var dropMenuVisible = computed(function () {\n    return states.visible && emptyText.value !== false;\n  });\n  watch(function () {\n    return selectDisabled.value;\n  }, function () {\n    nextTick(function () {\n      resetInputHeight();\n    });\n  });\n  watch(function () {\n    return props.placeholder;\n  }, function (val) {\n    states.cachedPlaceHolder = states.currentPlaceholder = val;\n  });\n  watch(function () {\n    return props.modelValue;\n  }, function (val, oldVal) {\n    var _a;\n\n    if (props.multiple) {\n      resetInputHeight();\n\n      if (val && val.length > 0 || input.value && states.query !== \"\") {\n        states.currentPlaceholder = \"\";\n      } else {\n        states.currentPlaceholder = states.cachedPlaceHolder;\n      }\n\n      if (props.filterable && !props.reserveKeyword) {\n        states.query = \"\";\n        handleQueryChange(states.query);\n      }\n    }\n\n    setSelected();\n\n    if (props.filterable && !props.multiple) {\n      states.inputLength = 20;\n    }\n\n    if (!isEqual(val, oldVal)) {\n      (_a = elFormItem.validate) == null ? void 0 : _a.call(elFormItem, \"change\");\n    }\n  }, {\n    flush: \"post\",\n    deep: true\n  });\n  watch(function () {\n    return states.visible;\n  }, function (val) {\n    var _a, _b;\n\n    if (!val) {\n      input.value && input.value.blur();\n      states.query = \"\";\n      states.previousQuery = null;\n      states.selectedLabel = \"\";\n      states.inputLength = 20;\n      states.menuVisibleOnFocus = false;\n      resetHoverIndex();\n      nextTick(function () {\n        if (input.value && input.value.value === \"\" && states.selected.length === 0) {\n          states.currentPlaceholder = states.cachedPlaceHolder;\n        }\n      });\n\n      if (!props.multiple) {\n        if (states.selected) {\n          if (props.filterable && props.allowCreate && states.createdSelected && states.createdLabel) {\n            states.selectedLabel = states.createdLabel;\n          } else {\n            states.selectedLabel = states.selected.currentLabel;\n          }\n\n          if (props.filterable) states.query = states.selectedLabel;\n        }\n\n        if (props.filterable) {\n          states.currentPlaceholder = states.cachedPlaceHolder;\n        }\n      }\n    } else {\n      (_b = (_a = popper.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);\n\n      if (props.filterable) {\n        states.filteredOptionsCount = states.optionsCount;\n        states.query = props.remote ? \"\" : states.selectedLabel;\n\n        if (props.multiple) {\n          input.value.focus();\n        } else {\n          if (states.selectedLabel) {\n            states.currentPlaceholder = states.selectedLabel;\n            states.selectedLabel = \"\";\n          }\n        }\n\n        handleQueryChange(states.query);\n\n        if (!props.multiple && !props.remote) {\n          queryChange.value.query = \"\";\n          triggerRef(queryChange);\n          triggerRef(groupQueryChange);\n        }\n      }\n    }\n\n    ctx.emit(\"visible-change\", val);\n  });\n  watch(function () {\n    return states.options.entries();\n  }, function () {\n    var _a, _b, _c;\n\n    if (isServer) return;\n    (_b = (_a = popper.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);\n\n    if (props.multiple) {\n      resetInputHeight();\n    }\n\n    var inputs = ((_c = selectWrapper.value) == null ? void 0 : _c.querySelectorAll(\"input\")) || [];\n\n    if ([].indexOf.call(inputs, document.activeElement) === -1) {\n      setSelected();\n    }\n\n    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {\n      checkDefaultFirstOption();\n    }\n  }, {\n    flush: \"post\"\n  });\n  watch(function () {\n    return states.hoverIndex;\n  }, function (val) {\n    if (typeof val === \"number\" && val > -1) {\n      hoverOption.value = optionsArray.value[val] || {};\n    }\n\n    optionsArray.value.forEach(function (option) {\n      option.hover = hoverOption.value === option;\n    });\n  });\n\n  var resetInputHeight = function resetInputHeight() {\n    if (props.collapseTags && !props.filterable) return;\n    nextTick(function () {\n      var _a, _b;\n\n      if (!reference.value) return;\n      var inputChildNodes = reference.value.$el.childNodes;\n      var input2 = [].filter.call(inputChildNodes, function (item) {\n        return item.tagName === \"INPUT\";\n      })[0];\n      var _tags = tags.value;\n      var sizeInMap = states.initialInputHeight || 40;\n      input2.style.height = states.selected.length === 0 ? \"\".concat(sizeInMap, \"px\") : \"\".concat(Math.max(_tags ? _tags.clientHeight + (_tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap), \"px\");\n      states.tagInMultiLine = parseFloat(input2.style.height) > sizeInMap;\n\n      if (states.visible && emptyText.value !== false) {\n        (_b = (_a = popper.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);\n      }\n    });\n  };\n\n  var handleQueryChange = function handleQueryChange(val) {\n    if (states.previousQuery === val || states.isOnComposition) return;\n\n    if (states.previousQuery === null && (typeof props.filterMethod === \"function\" || typeof props.remoteMethod === \"function\")) {\n      states.previousQuery = val;\n      return;\n    }\n\n    states.previousQuery = val;\n    nextTick(function () {\n      var _a, _b;\n\n      if (states.visible) (_b = (_a = popper.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);\n    });\n    states.hoverIndex = -1;\n\n    if (props.multiple && props.filterable) {\n      nextTick(function () {\n        var length = input.value.length * 15 + 20;\n        states.inputLength = props.collapseTags ? Math.min(50, length) : length;\n        managePlaceholder();\n        resetInputHeight();\n      });\n    }\n\n    if (props.remote && typeof props.remoteMethod === \"function\") {\n      states.hoverIndex = -1;\n      props.remoteMethod(val);\n    } else if (typeof props.filterMethod === \"function\") {\n      props.filterMethod(val);\n      triggerRef(groupQueryChange);\n    } else {\n      states.filteredOptionsCount = states.optionsCount;\n      queryChange.value.query = val;\n      triggerRef(queryChange);\n      triggerRef(groupQueryChange);\n    }\n\n    if (props.defaultFirstOption && (props.filterable || props.remote) && states.filteredOptionsCount) {\n      checkDefaultFirstOption();\n    }\n  };\n\n  var managePlaceholder = function managePlaceholder() {\n    if (states.currentPlaceholder !== \"\") {\n      states.currentPlaceholder = input.value.value ? \"\" : states.cachedPlaceHolder;\n    }\n  };\n\n  var checkDefaultFirstOption = function checkDefaultFirstOption() {\n    var optionsInDropdown = optionsArray.value.filter(function (n) {\n      return n.visible && !n.disabled && !n.groupDisabled;\n    });\n    var userCreatedOption = optionsInDropdown.filter(function (n) {\n      return n.created;\n    })[0];\n    var firstOriginOption = optionsInDropdown[0];\n    states.hoverIndex = getValueIndex(optionsArray.value, userCreatedOption || firstOriginOption);\n  };\n\n  var setSelected = function setSelected() {\n    var _a;\n\n    if (!props.multiple) {\n      var option = getOption(props.modelValue);\n\n      if ((_a = option.props) == null ? void 0 : _a.created) {\n        states.createdLabel = option.props.value;\n        states.createdSelected = true;\n      } else {\n        states.createdSelected = false;\n      }\n\n      states.selectedLabel = option.currentLabel;\n      states.selected = option;\n      if (props.filterable) states.query = states.selectedLabel;\n      return;\n    }\n\n    var result = [];\n\n    if (Array.isArray(props.modelValue)) {\n      props.modelValue.forEach(function (value) {\n        result.push(getOption(value));\n      });\n    }\n\n    states.selected = result;\n    nextTick(function () {\n      resetInputHeight();\n    });\n  };\n\n  var getOption = function getOption(value) {\n    var option;\n    var isObjectValue = toRawType(value).toLowerCase() === \"object\";\n    var isNull = toRawType(value).toLowerCase() === \"null\";\n    var isUndefined = toRawType(value).toLowerCase() === \"undefined\";\n\n    for (var i = states.cachedOptions.size - 1; i >= 0; i--) {\n      var cachedOption = cachedOptionsArray.value[i];\n      var isEqualValue = isObjectValue ? getValueByPath(cachedOption.value, props.valueKey) === getValueByPath(value, props.valueKey) : cachedOption.value === value;\n\n      if (isEqualValue) {\n        option = {\n          value: value,\n          currentLabel: cachedOption.currentLabel,\n          isDisabled: cachedOption.isDisabled\n        };\n        break;\n      }\n    }\n\n    if (option) return option;\n    var label = !isObjectValue && !isNull && !isUndefined ? value : \"\";\n    var newOption = {\n      value: value,\n      currentLabel: label\n    };\n\n    if (props.multiple) {\n      ;\n      newOption.hitState = false;\n    }\n\n    return newOption;\n  };\n\n  var resetHoverIndex = function resetHoverIndex() {\n    setTimeout(function () {\n      var valueKey = props.valueKey;\n\n      if (!props.multiple) {\n        states.hoverIndex = optionsArray.value.findIndex(function (item) {\n          return getValueKey(item) === getValueKey(states.selected);\n        });\n      } else {\n        if (states.selected.length > 0) {\n          states.hoverIndex = Math.min.apply(null, states.selected.map(function (selected) {\n            return optionsArray.value.findIndex(function (item) {\n              return getValueByPath(item, valueKey) === getValueByPath(selected, valueKey);\n            });\n          }));\n        } else {\n          states.hoverIndex = -1;\n        }\n      }\n    }, 300);\n  };\n\n  var handleResize = function handleResize() {\n    var _a, _b;\n\n    resetInputWidth();\n    (_b = (_a = popper.value) == null ? void 0 : _a.update) == null ? void 0 : _b.call(_a);\n    if (props.multiple) resetInputHeight();\n  };\n\n  var resetInputWidth = function resetInputWidth() {\n    var _a;\n\n    states.inputWidth = (_a = reference.value) == null ? void 0 : _a.$el.getBoundingClientRect().width;\n  };\n\n  var onInputChange = function onInputChange() {\n    if (props.filterable && states.query !== states.selectedLabel) {\n      states.query = states.selectedLabel;\n      handleQueryChange(states.query);\n    }\n  };\n\n  var debouncedOnInputChange = debounce(function () {\n    onInputChange();\n  }, debounce$1.value);\n  var debouncedQueryChange = debounce(function (e) {\n    handleQueryChange(e.target.value);\n  }, debounce$1.value);\n\n  var emitChange = function emitChange(val) {\n    if (!isEqual(props.modelValue, val)) {\n      ctx.emit(CHANGE_EVENT, val);\n    }\n  };\n\n  var deletePrevTag = function deletePrevTag(e) {\n    if (e.target.value.length <= 0 && !toggleLastOptionHitState()) {\n      var value = props.modelValue.slice();\n      value.pop();\n      ctx.emit(UPDATE_MODEL_EVENT, value);\n      emitChange(value);\n    }\n\n    if (e.target.value.length === 1 && props.modelValue.length === 0) {\n      states.currentPlaceholder = states.cachedPlaceHolder;\n    }\n  };\n\n  var deleteTag = function deleteTag(event, tag) {\n    var index = states.selected.indexOf(tag);\n\n    if (index > -1 && !selectDisabled.value) {\n      var value = props.modelValue.slice();\n      value.splice(index, 1);\n      ctx.emit(UPDATE_MODEL_EVENT, value);\n      emitChange(value);\n      ctx.emit(\"remove-tag\", tag.value);\n    }\n\n    event.stopPropagation();\n  };\n\n  var deleteSelected = function deleteSelected(event) {\n    event.stopPropagation();\n    var value = props.multiple ? [] : \"\";\n\n    if (typeof value !== \"string\") {\n      var _iterator = _createForOfIteratorHelper(states.selected),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          if (item.isDisabled) value.push(item.value);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    ctx.emit(UPDATE_MODEL_EVENT, value);\n    emitChange(value);\n    states.visible = false;\n    ctx.emit(\"clear\");\n  };\n\n  var handleOptionSelect = function handleOptionSelect(option, byClick) {\n    if (props.multiple) {\n      var value = (props.modelValue || []).slice();\n      var optionIndex = getValueIndex(value, option.value);\n\n      if (optionIndex > -1) {\n        value.splice(optionIndex, 1);\n      } else if (props.multipleLimit <= 0 || value.length < props.multipleLimit) {\n        value.push(option.value);\n      }\n\n      ctx.emit(UPDATE_MODEL_EVENT, value);\n      emitChange(value);\n\n      if (option.created) {\n        states.query = \"\";\n        handleQueryChange(\"\");\n        states.inputLength = 20;\n      }\n\n      if (props.filterable) input.value.focus();\n    } else {\n      ctx.emit(UPDATE_MODEL_EVENT, option.value);\n      emitChange(option.value);\n      states.visible = false;\n    }\n\n    states.isSilentBlur = byClick;\n    setSoftFocus();\n    if (states.visible) return;\n    nextTick(function () {\n      scrollToOption(option);\n    });\n  };\n\n  var getValueIndex = function getValueIndex() {\n    var arr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var value = arguments.length > 1 ? arguments[1] : undefined;\n    if (!isObject(value)) return arr.indexOf(value);\n    var valueKey = props.valueKey;\n    var index = -1;\n    arr.some(function (item, i) {\n      if (getValueByPath(item, valueKey) === getValueByPath(value, valueKey)) {\n        index = i;\n        return true;\n      }\n\n      return false;\n    });\n    return index;\n  };\n\n  var setSoftFocus = function setSoftFocus() {\n    states.softFocus = true;\n\n    var _input = input.value || reference.value;\n\n    if (_input) {\n      _input.focus();\n    }\n  };\n\n  var scrollToOption = function scrollToOption(option) {\n    var _a, _b, _c, _d;\n\n    var targetOption = Array.isArray(option) ? option[0] : option;\n    var target = null;\n\n    if (targetOption == null ? void 0 : targetOption.value) {\n      var options = optionsArray.value.filter(function (item) {\n        return item.value === targetOption.value;\n      });\n\n      if (options.length > 0) {\n        target = options[0].$el;\n      }\n    }\n\n    if (popper.value && target) {\n      var menu = (_c = (_b = (_a = popper.value) == null ? void 0 : _a.popperRef) == null ? void 0 : _b.querySelector) == null ? void 0 : _c.call(_b, \".el-select-dropdown__wrap\");\n\n      if (menu) {\n        scrollIntoView(menu, target);\n      }\n    }\n\n    (_d = scrollbar.value) == null ? void 0 : _d.handleScroll();\n  };\n\n  var onOptionCreate = function onOptionCreate(vm) {\n    states.optionsCount++;\n    states.filteredOptionsCount++;\n    states.options.set(vm.value, vm);\n    states.cachedOptions.set(vm.value, vm);\n  };\n\n  var onOptionDestroy = function onOptionDestroy(key) {\n    states.optionsCount--;\n    states.filteredOptionsCount--;\n    states.options[\"delete\"](key);\n  };\n\n  var resetInputState = function resetInputState(e) {\n    if (e.code !== EVENT_CODE.backspace) toggleLastOptionHitState(false);\n    states.inputLength = input.value.length * 15 + 20;\n    resetInputHeight();\n  };\n\n  var toggleLastOptionHitState = function toggleLastOptionHitState(hit) {\n    if (!Array.isArray(states.selected)) return;\n    var option = states.selected[states.selected.length - 1];\n    if (!option) return;\n\n    if (hit === true || hit === false) {\n      option.hitState = hit;\n      return hit;\n    }\n\n    option.hitState = !option.hitState;\n    return option.hitState;\n  };\n\n  var handleComposition = function handleComposition(event) {\n    var text = event.target.value;\n\n    if (event.type === \"compositionend\") {\n      states.isOnComposition = false;\n      nextTick(function () {\n        return handleQueryChange(text);\n      });\n    } else {\n      var lastCharacter = text[text.length - 1] || \"\";\n      states.isOnComposition = !isKorean(lastCharacter);\n    }\n  };\n\n  var handleMenuEnter = function handleMenuEnter() {\n    nextTick(function () {\n      return scrollToOption(states.selected);\n    });\n  };\n\n  var handleFocus = function handleFocus(event) {\n    if (!states.softFocus) {\n      if (props.automaticDropdown || props.filterable) {\n        states.visible = true;\n\n        if (props.filterable) {\n          states.menuVisibleOnFocus = true;\n        }\n      }\n\n      ctx.emit(\"focus\", event);\n    } else {\n      states.softFocus = false;\n    }\n  };\n\n  var blur = function blur() {\n    states.visible = false;\n    reference.value.blur();\n  };\n\n  var handleBlur = function handleBlur(event) {\n    nextTick(function () {\n      if (states.isSilentBlur) {\n        states.isSilentBlur = false;\n      } else {\n        ctx.emit(\"blur\", event);\n      }\n    });\n    states.softFocus = false;\n  };\n\n  var handleClearClick = function handleClearClick(event) {\n    deleteSelected(event);\n  };\n\n  var handleClose = function handleClose() {\n    states.visible = false;\n  };\n\n  var toggleMenu = function toggleMenu() {\n    if (props.automaticDropdown) return;\n\n    if (!selectDisabled.value) {\n      if (states.menuVisibleOnFocus) {\n        states.menuVisibleOnFocus = false;\n      } else {\n        states.visible = !states.visible;\n      }\n\n      if (states.visible) {\n        ;\n        (input.value || reference.value).focus();\n      }\n    }\n  };\n\n  var selectOption = function selectOption() {\n    if (!states.visible) {\n      toggleMenu();\n    } else {\n      if (optionsArray.value[states.hoverIndex]) {\n        handleOptionSelect(optionsArray.value[states.hoverIndex], void 0);\n      }\n    }\n  };\n\n  var getValueKey = function getValueKey(item) {\n    return isObject(item.value) ? getValueByPath(item.value, props.valueKey) : item.value;\n  };\n\n  var optionsAllDisabled = computed(function () {\n    return optionsArray.value.filter(function (option) {\n      return option.visible;\n    }).every(function (option) {\n      return option.disabled;\n    });\n  });\n\n  var navigateOptions = function navigateOptions(direction) {\n    if (!states.visible) {\n      states.visible = true;\n      return;\n    }\n\n    if (states.options.size === 0 || states.filteredOptionsCount === 0) return;\n    if (states.isOnComposition) return;\n\n    if (!optionsAllDisabled.value) {\n      if (direction === \"next\") {\n        states.hoverIndex++;\n\n        if (states.hoverIndex === states.options.size) {\n          states.hoverIndex = 0;\n        }\n      } else if (direction === \"prev\") {\n        states.hoverIndex--;\n\n        if (states.hoverIndex < 0) {\n          states.hoverIndex = states.options.size - 1;\n        }\n      }\n\n      var option = optionsArray.value[states.hoverIndex];\n\n      if (option.disabled === true || option.groupDisabled === true || !option.visible) {\n        navigateOptions(direction);\n      }\n\n      nextTick(function () {\n        return scrollToOption(hoverOption.value);\n      });\n    }\n  };\n\n  return {\n    optionsArray: optionsArray,\n    selectSize: selectSize,\n    handleResize: handleResize,\n    debouncedOnInputChange: debouncedOnInputChange,\n    debouncedQueryChange: debouncedQueryChange,\n    deletePrevTag: deletePrevTag,\n    deleteTag: deleteTag,\n    deleteSelected: deleteSelected,\n    handleOptionSelect: handleOptionSelect,\n    scrollToOption: scrollToOption,\n    readonly: readonly,\n    resetInputHeight: resetInputHeight,\n    showClose: showClose,\n    iconComponent: iconComponent,\n    iconReverse: iconReverse,\n    showNewOption: showNewOption,\n    collapseTagSize: collapseTagSize,\n    setSelected: setSelected,\n    managePlaceholder: managePlaceholder,\n    selectDisabled: selectDisabled,\n    emptyText: emptyText,\n    toggleLastOptionHitState: toggleLastOptionHitState,\n    resetInputState: resetInputState,\n    handleComposition: handleComposition,\n    onOptionCreate: onOptionCreate,\n    onOptionDestroy: onOptionDestroy,\n    handleMenuEnter: handleMenuEnter,\n    handleFocus: handleFocus,\n    blur: blur,\n    handleBlur: handleBlur,\n    handleClearClick: handleClearClick,\n    handleClose: handleClose,\n    toggleMenu: toggleMenu,\n    selectOption: selectOption,\n    getValueKey: getValueKey,\n    navigateOptions: navigateOptions,\n    dropMenuVisible: dropMenuVisible,\n    queryChange: queryChange,\n    groupQueryChange: groupQueryChange,\n    reference: reference,\n    input: input,\n    popper: popper,\n    tags: tags,\n    selectWrapper: selectWrapper,\n    scrollbar: scrollbar\n  };\n};\n\nexport { useSelect, useSelectStates };","map":null,"metadata":{},"sourceType":"module"}